#+title:   Emacs configuration
#+STARTUP: showall

* Introduction

This is my personal Emacs configuration. It is implemented using literate programming in org-mode. The way this works is that upon Emacs startup:

1. The two-liner =init.el= config file is loaded, which in turns calls the =org-babel-load-file= function with this file.
2. The org file is processed and the code blocks are tangled into a =config.el= file.
3. The generated configuration file is then loaded.

* General setup

Enable lexical binding.

#+begin_src emacs-lisp :tangle yes
;; -*- lexical-binding: t -*-
#+end_src

Add personal details.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name (base64-decode-string "VHVvbW8gVmlyb2xhaW5lbg==")
      user-mail-address (base64-decode-string "dHVvbW8udmlyb2xhaW5lbkBzaWlsaS5jb20="))
#+end_src

Is this the work laptop or something else?

#+begin_src emacs-lisp :tangle yes
(defconst work-laptop-p
  (equal (system-name) "siilim211207.local"))
#+end_src

Set configuration file name for later reference.

#+begin_src emacs-lisp :tangle yes
(defconst config-file "config.org")
#+end_src

Configure path.

#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure t
  :init
  (when (memq window-system '(mac ns x))
    (require 'exec-path-from-shell)
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "JAVA_HOME" "MAVEN_OPTS" "VARMA_GPG_SYMMETRIC_PASSPHRASE"
                   "CLAUDE_API_KEY" "KAPSI_PASS"
                   "VARMA_GPG_SYMMETRIC_PASSPHRASE_PROD" "VARMA_ARTIFACTORY_USERNAME" "VARMA_ARTIFACTORY_PASSWORD" "VARMA_ELAMA_BOT_USERNAME" "VARMA_ELAMA_BOT_PASSWORD"))
      (add-to-list 'exec-path-from-shell-variables var))
    (exec-path-from-shell-initialize)))
#+end_src

Configure repos.

#+begin_src emacs-lisp :tangle yes
(setq package-enable-at-startup nil
      package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))

(use-package quelpa :ensure t)
(use-package quelpa-use-package :ensure t)
#+end_src

Configure =use-package=.

#+begin_src emacs-lisp :tangle yes
(setq use-package-always-ensure t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile (require 'use-package))
#+end_src

The cursor may blink. Not in image buffers though.

#+begin_src emacs-lisp :tangle yes
(blink-cursor-mode t)

(defun disable-cursor-for-viewing ()
  (setq-local cursor-type nil)
  (blink-cursor-mode -1))

(defun restore-cursor ()
  (kill-local-variable 'cursor-type)
  (blink-cursor-mode 1))

(add-hook 'image-mode-hook #'disable-cursor-for-viewing)
(add-hook 'reader-mode-hook #'disable-cursor-for-viewing)

;; Restore when exiting
(add-hook 'change-major-mode-hook #'restore-cursor)
#+end_src

Disable unnecessary stuff.

#+begin_src emacs-lisp :tangle yes
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode t)
(setq inhibit-startup-screen t)
(setq ring-bell-function 'ignore)
(setq use-short-answers t)
;; (setq initial-scratch-message "")
#+end_src

Set 10MB as the limit for garbage collection.

#+begin_src emacs-lisp :tangle yes
(setq gc-cons-threshold 10000000)
#+end_src

Warn when opening files bigger than 100MB.

#+begin_src emacs-lisp :tangle yes
(setq large-file-warning-threshold 100000000)
#+end_src

Prefer latest bytecode.

#+begin_src emacs-lisp :tangle yes
(setq load-prefer-newer t)
#+end_src

Increase kill-ring capacity.

#+begin_src emacs-lisp :tangle yes
(setq kill-ring-max 1000)
#+end_src

Replace a selection with yanked content.

#+begin_src emacs-lisp :tangle yes
(delete-selection-mode 1)
#+end_src

Shut Emacs down when I'm asking, even if processes are running.

#+begin_src emacs-lisp :tangle yes
(setq confirm-kill-processes nil)
#+end_src

Revert buffers when the underlying file has changed.

#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode 1)

(setq global-auto-revert-non-file-buffers t)
#+end_src

Mac-specific settings.

#+begin_src emacs-lisp :tangle yes
(setq mac-option-modifier 'nil
      mac-command-modifier 'meta
      mac-function-modifier 'super
      select-enable-clipboard t)
#+end_src

[[https://lmno.lol/alvaro/hey-mouse-dont-mess-with-my-emacs-font-size][Prevent]] mouse / trackpad input from accidentally resizing fonts.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "<pinch>") 'ignore)
(global-set-key (kbd "<C-wheel-up>") 'ignore)
(global-set-key (kbd "<C-wheel-down>") 'ignore)
#+end_src

UTF-8 should be preferred everywhere.

#+begin_src emacs-lisp :tangle yes
(set-charset-priority 'unicode)
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

Highlight the current line.

#+begin_src emacs-lisp :tangle yes
(use-package hl-line
  :config
  (global-hl-line-mode +1))
#+end_src

Create a directory for savefiles if it doesn't exist.

#+begin_src emacs-lisp :tangle yes
(defconst tv-savefile-dir (expand-file-name "etc/savefile" user-emacs-directory))

(unless (file-exists-p "etc")
  (make-directory "etc"))

(unless (file-exists-p tv-savefile-dir)
  (make-directory tv-savefile-dir))
#+end_src

Put backup files under =etc/.tmp/=.

#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist `(("." . ,(expand-file-name "etc/.tmp/backups/"
                                                         user-emacs-directory))))
(setq backup-by-copying t)

(setq delete-by-moving-to-trash t)

(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

Dump custom settings in a separate file.

#+begin_src emacs-lisp :tangle yes
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file t)
#+end_src

Store miscellaneous files under =/etc=.

#+begin_src emacs-lisp :tangle yes
(setq bookmark-default-file (expand-file-name "etc/bookmarks" user-emacs-directory))
#+end_src

Allow recursive minibuffers, i.e. using minibuffer inside minibuffer. This is useful for example when yanking stuff from the kill-ring using M-y.

#+begin_src emacs-lisp :tangle yes
(setq enable-recursive-minibuffers t)
#+end_src

Set keybindings for profiler.

#+begin_src emacs-lisp :tangle yes
(use-package profiler
  :bind
  ("C-x P r"  . profiler-report)
  ("C-x P 1"  . profiler-start)
  ("C-x P 0"  . profiler-stop))
#+end_src

* Appearance

Use =doom-dracula= theme.

#+begin_src emacs-lisp :tangle yes
(use-package doom-themes
  :ensure t
  :custom
  (doom-dracula-brighter-modeline t)
  (doom-dracula-brighter-comments t)
  (doom-dracula-colorful-headers t)
  :config
  (load-theme 'doom-dracula t))
#+end_src

Also install [[https://protesilaos.com/emacs/ef-themes][ef-themes]].

#+begin_src emacs-lisp :tangle yes
(use-package ef-themes
  :ensure t)
#+end_src

Disable custom themes before loading a new one.

#+begin_src emacs-lisp :tangle yes
(defun disable-custom-themes (&optional theme no-confirm no-enable)
  (mapc #'disable-theme custom-enabled-themes))

(advice-add 'load-theme :before #'disable-custom-themes)
#+end_src

Add helpers to switch between themes.

#+begin_src emacs-lisp :tangle yes
(defun tv/load-light-theme ()
  "Load light theme."
  (interactive)
  (load-theme 'modus-operandi t)
  (set-frame-parameter nil 'ns-appearance 'light))

(defun tv/load-dark-theme ()
  "Load dark theme."
  (interactive)
  (load-theme 'doom-dracula t)
  (set-frame-parameter nil 'ns-appearance 'dark))
#+end_src

Let's try out Fontaine for setting up fonts.

#+begin_src emacs-lisp :tangle yes
(use-package fontaine
  :ensure t
  :bind ("C-c ö" . fontaine-toggle-preset)
  :hook
  ((after-init . fontaine-mode)
   (after-init . (lambda ()
                   ;; Set last preset or fall back to desired style from `fontaine-presets'.
                   (fontaine-set-preset (or (fontaine-restore-latest-preset) 'regular)))))
  :config
  (setq fontaine-presets
        '((small
           :default-height 100)
          (regular) ; like this it uses all the fallback values and is named `regular'
          (medium
           :default-family "JetBrains Mono"
           :default-height 140
           :fixed-pitch-family "JetBrains Mono"
           :variable-pitch-family "SF Pro")
          (large
           :default-height 200)
          (presentation
           :default-height 180)
          (jumbo
           :inherit medium
           :default-height 260)
          (t
           :default-family "SF Mono"
           :default-weight regular
           :default-slant normal
           :default-width normal
           :default-height 140

           :fixed-pitch-family "JetBrains Mono"
           :fixed-pitch-weight nil
           :fixed-pitch-slant nil
           :fixed-pitch-width nil
           :fixed-pitch-height 180

           :fixed-pitch-serif-family nil
           :fixed-pitch-serif-weight nil
           :fixed-pitch-serif-slant nil
           :fixed-pitch-serif-width nil
           :fixed-pitch-serif-height 1.2

           :variable-pitch-family "IBM Plex Sans"
           :variable-pitch-weight nil
           :variable-pitch-slant nil
           :variable-pitch-width nil
           :variable-pitch-height 150

           :bold-family nil
           :bold-slant nil
           :bold-weight bold
           :bold-width nil
           :bold-height 1.0

           :italic-family nil
           :italic-weight nil
           :italic-slant italic
           :italic-width nil
           :italic-height 1.0

           :line-spacing nil))))

(set-face-attribute 'font-lock-comment-face nil :slant 'italic)
(set-face-attribute 'font-lock-keyword-face nil :slant 'italic)
#+end_src

Tabs should never ever be used for indentation. If they are, they should look silly.

#+begin_src emacs-lisp :tangle yes
(setq-default tab-width 8)
(setq-default indent-tabs-mode nil)
#+end_src

Require a newline at the end.

#+begin_src emacs-lisp :tangle yes
(setq require-final-newline t)
#+end_src

#+begin_src emacs-lisp :tangle yes
(setq-default sentence-end-double-space nil)
#+end_src

Maximize the frame on startup.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

No lockfiles.

#+begin_src emacs-lisp :tangle yes
(setq create-lockfiles nil)
#+end_src

Wrap lines by default. I hate horizontal scrolling.

#+begin_src emacs-lisp :tangle yes
(setq global-visual-line-mode t)
#+end_src

Make the titlebar transparent.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src

We are using a dark color theme by default, which the title bar should reflect too.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'default-frame-alist '(ns-appearance . dark))
#+end_src

Remove the icon from the titlebar.

#+begin_src emacs-lisp :tangle yes
(setq ns-use-proxy-icon nil)
#+end_src

Suppress compilation warnings.

#+begin_src emacs-lisp :tangle yes
(setq native-comp-async-report-warnings-errors nil)
#+end_src

Moody, a mode line.

#+begin_src emacs-lisp :tangle yes
(use-package moody
  :config
  (moody-replace-mode-line-front-space)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode))

(use-package minions
  :ensure t
  :custom
  (minions-mode-line-lighter "…")
  (minions-mode-line-delimiters '("" . ""))
  :config
  (minions-mode +1))
#+end_src

Scroll smoothly when using a mouse or trackpad. While this for me equals basically never, the [[https://github.com/jdtsmith/ultra-scroll][ultra-scroll]] package seems to be great.

#+begin_src emacs-lisp :tangle yes
;; (package-vc-install '(ultra-scroll :vc-backend Git :url  "https://github.com/jdtsmith/ultra-scroll"))

(defvar us-path "~/dev/ultra-scroll")

(use-package ultra-scroll
  :if (file-directory-p us-path)
  :load-path us-path
  :init (setq scroll-conservatively 101 ; important!
              scroll-margin 0)
  :config
  (ultra-scroll-mode 1))

(unless (file-directory-p us-path)
  (pixel-scroll-precision-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package hide-mode-line
  :ensure t)
#+end_src

Use [[https://github.com/wolray/symbol-overlay][symbol-overlay]] mode to highlight symbols matching the one under the cursor.

#+begin_src emacs-lisp :tangle yes
(use-package symbol-overlay
  :ensure t
  :hook (prog-mode . symbol-overlay-mode))
#+end_src

Use =spacious-padding=.

#+begin_src emacs-lisp :tangle yes
(use-package spacious-padding
  :ensure t
  :defer
  :hook (after-init . spacious-padding-mode))
#+end_src

Setup line numbers.

#+begin_src emacs-lisp :tangle yes
(setq display-line-numbers-type 'relative)

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'conf-mode-hook #'display-line-numbers-mode)
#+end_src

Create missing parent folders automatically. Source: [[https://github.com/bbatsov/emacs.d/blob/master/init.el][bbatsov]].

#+begin_src emacs-lisp :tangle yes
;; auto-create missing folders
(defun er-auto-create-missing-dirs ()
  "Make missing parent directories automatically."
  (let ((target-dir (file-name-directory buffer-file-name)))
    (unless (file-exists-p target-dir)
      (make-directory target-dir t))))

(add-to-list 'find-file-not-found-functions #'er-auto-create-missing-dirs)
#+end_src

We don't want line numbers to be shown in org-mode buffers, apart from this one. Here, also =electric-pair-mode= should be enabled.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'(lambda ()
                             (interactive)
                             (when (cl-search config-file (buffer-name))
                               (electric-pair-mode)
                               (display-line-numbers-mode))))
#+end_src

** Rainbow-mode

Rainbow mode shows color codes as well as some other values (like the value `red' in CSS) in color.

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode
  :ensure t
  :hook (prog-mode . rainbow-mode))
#+end_src

** Rainbow delimiters-mode

Rainbow-delimiters are useful in lisps.

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Line spacing

A bit wider line spacing than the default.

#+begin_src emacs-lisp :tangle yes
(setq-default line-spacing 0.15)
#+end_src

** Emacs reader

[[https://codeberg.org/divyaranjan/emacs-reader][Emacs Reader]] aims to be an all-in-one reading solution for various filetypes. It seems to work very well.

#+begin_src emacs-lisp :tangle yes
(setq package-vc-allow-build-commands t)
(use-package reader
  :vc (:url "https://codeberg.org/divyaranjan/emacs-reader"
            :make "all"))
#+end_src

** Olivetti mode

Olivetti mode squeezes the buffer into a column of limited width. This helps readability.

#+begin_src emacs-lisp :tangle yes
(use-package olivetti
  :ensure t
  :custom (olivetti-body-width 94))
#+end_src

** Pulse

#+begin_src emacs-lisp :tangle yes
(use-package pulse
  :ensure nil
  :init
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (dolist (command '(scroll-up-command
                     scroll-down-command
                     evil-scroll-up
                     evil-scroll-down
                     windmove-left
                     windmove-right
                     windmove-up
                     windmove-down
                     move-to-window-line-top-bottom
                     recenter-top-bottom
                     other-window))
    (advice-add command :after #'pulse-line)))
#+end_src

** Whitespace

Show trailing whitespace.

#+begin_src emacs-lisp :tangle yes
(setq show-trailing-whitespace t)
#+end_src

Make it go away.

#+begin_src emacs-lisp :tangle yes
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+end_src

** Sudo edit

#+begin_src emacs-lisp :tangle yes
(use-package sudo-edit
  :ensure t
  :defer t
  :config
  (global-set-key (kbd "C-c C-r") 'sudo-edit))
#+end_src

* Tree-sitter

Use =tree-sitter=.

#+begin_src emacs-lisp :tangle yes
(setq treesit-extra-load-path `(,(concat user-emacs-directory "var/tree-sitter-dist/")
                                ,(concat user-emacs-directory "var/tree-sitter")))

(defun tv/turn-on-tree-sitter-mode-if-the-file-is-not-overtly-large ()
  (when (< (buffer-size) 1000000)
    (turn-on-tree-sitter-mode)))

(use-package tree-sitter
  :hook ((tree-sitter-after-on . tree-sitter-hl-mode)
         (prog-mode . tv/turn-on-tree-sitter-mode-if-the-file-is-not-overtly-large))
  :config (require 'tree-sitter-langs)
  ;; This makes every node a link to a section of code
  (setq tree-sitter-debug-jump-buttons t
        ;; and this highlights the entire sub tree in your code
        tree-sitter-debug-highlight-jump-region t))

(use-package tree-sitter-langs
  :ensure t
  :after tree-sitter)

(use-package treesit-auto
  :ensure t
  :custom (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src

* Evil mode

Vim keybindings here.

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :ensure t
  :demand t
  :bind (("<escape>" . keyboard-escape-quit))
  :init
  (setq evil-want-keybinding nil)
  ;; no vim insert bindings
  :config
  (evil-mode 1)
  ;; (evil-set-undo-system 'vundo)
  ;; (evil-set-undo-system 'undo-tree)
  (evil-set-undo-system 'undo-redo)
  (setq evil-undo-system 'undo-fu)
  (setq evil-split-window-below t
        evil-vsplit-window-right t)
  (setq evil-ex-substitute-global t)
  (setq evil-kill-on-visual-paste nil)
  (setq evil-shift-width 2)
  (setq evil-respect-visual-line-mode t)
  (evil-add-command-properties #'flymake-goto-next-error :jump t)
  (evil-add-command-properties #'evil-scroll-up :jump t)
  (evil-add-command-properties #'consult-grep :jump t))

(use-package undo-fu
  :ensure t
  :after evil
  :custom
  (setopt undo-limit (* 13 160000))
  (setopt undo-outer-limit (* 13 24000000))
  (setopt undo-strong-limit (* 13 240000))
  :config
  (setq undo-fu-allow-undo-in-region t))

(use-package undo-fu-session
  :ensure t
  :hook (after-init . undo-fu-session-global-mode)
  :config
  (setq undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")
        undo-fu-session-file-limit 10))

(use-package evil-collection
  :ensure t
  :after evil
  :custom (evil-want-integration t)
  :config
  (evil-collection-init))
#+end_src

#+begin_src emacs-lisp :tangle yes
(defconst tv/undo-dir-name "etc/undo")
(defconst tv/undo-dir (expand-file-name tv/undo-dir-name user-emacs-directory))

(unless (file-exists-p tv/undo-dir)
  (make-directory tv/undo-dir))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package evil-visual-mark-mode
  :ensure t
  :config
  (evil-visual-mark-mode +1))
#+end_src

Vundo.

#+begin_src emacs-lisp :tangle yes
(use-package vundo
  :commands (vundo)
  :ensure t
  :config
  ;; Take less on-screen space.
  (setq vundo-compact-display t)
  (define-key vundo-mode-map (kbd "l") #'vundo-forward)
  (define-key vundo-mode-map (kbd "<right>") #'vundo-forward)
  (define-key vundo-mode-map (kbd "h") #'vundo-backward)
  (define-key vundo-mode-map (kbd "<left>") #'vundo-backward)
  (define-key vundo-mode-map (kbd "j") #'vundo-next)
  (define-key vundo-mode-map (kbd "<down>") #'vundo-next)
  (define-key vundo-mode-map (kbd "k") #'vundo-previous)
  (define-key vundo-mode-map (kbd "<up>") #'vundo-previous)
  (define-key vundo-mode-map (kbd "<home>") #'vundo-stem-root)
  (define-key vundo-mode-map (kbd "<end>") #'vundo-stem-end)
  (define-key vundo-mode-map (kbd "q") #'vundo-quit)
  (define-key vundo-mode-map (kbd "C-g") #'vundo-quit)
  (define-key vundo-mode-map (kbd "RET") #'vundo-confirm))

(with-eval-after-load 'evil (evil-define-key 'normal 'global (kbd "C-M-u") 'vundo))
#+end_src

Evil-surround.

#+begin_src emacs-lisp :tangle yes
(use-package evil-surround
  :ensure t
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

Evil-matchit.

#+begin_src emacs-lisp :tangle yes
(use-package evil-matchit
  :ensure t
  :after evil
  :config
  (global-evil-matchit-mode 1))
#+end_src

Comment out / in stuff easily.

#+begin_src emacs-lisp :tangle yes
(use-package evil-commentary
  :ensure t
  :after evil
  :config
  (evil-commentary-mode))
#+end_src

=evil-owl= provides a view to register contents.

#+begin_src emacs-lisp :tangle yes
(use-package evil-owl
  :ensure t
  :after evil
  :config
  (setq evil-owl-max-string-length 500)
  (setq evil-owl-idle-delay 0.5)
  (add-to-list 'display-buffer-alist
               '("*evil-owl*"
                 (display-buffer-in-side-window)
                 (side . bottom)
                 (window-height . 0.3)))
  (evil-owl-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'evil
  (defalias #'forward-evil-word #'forward-evil-symbol)
  ;; make evil-search-word look for symbol rather than word boundaries
  (setq-default evil-symbol-word-search t)
  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat)
  (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance))
#+end_src

This maybe fixes some indentation issues in org mode.

#+begin_src emacs-lisp :tangle yes
(setq evil-want-c-i-jump nil)
#+end_src

[[https://zck.org/balance-emacs-windows][Balance]] windows automatically.

#+begin_src emacs-lisp :tangle yes
(seq-doseq (fn (list #'split-window #'delete-window))
  (advice-add fn
              :after
              #'(lambda (&rest _args) (balance-windows))))
#+end_src

* Version control

Magit is the Git package.

#+begin_src emacs-lisp :tangle yes
(defun tv/kill-magit-diff-buffer-in-current-repo (&rest _)
  "Delete the magit-diff buffer related to the current repo."
  (let ((magit-diff-buffer-in-current-repo
         (magit-mode-get-buffer 'magit-diff-mode)))
    (kill-buffer magit-diff-buffer-in-current-repo)))

(defun tv/mu-magit-kill-buffers ()
  "Restore window configuration and kill all Magit buffers."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))

(use-package magit
  :defer
  :ensure t
  :config
  (add-hook 'git-commit-setup-hook
            (lambda ()
              (add-hook 'with-editor-post-finish-hook
                        #'tv/kill-magit-diff-buffer-in-current-repo
                        nil t)))
  (evil-define-key 'normal magit-status-mode-map
    "C-l" #'evil-window-right
    "C-h" #'evil-window-left
    "C-k" #'evil-window-prev
    "C-j" #'evil-window-next
    "q" #'tv/mu-magit-kill-buffers)
  (add-hook 'magit-post-refresh-hook
            #'git-gutter:update-all-windows))

(use-package git-gutter
  :ensure t
  :defer
  :hook (after-init . global-git-gutter-mode))

(use-package git-timemachine
  :ensure t
  :defer
  :bind (("s-g" . git-timemachine)))
#+end_src

* Keybindings

Use =which-key=, in minibuffer.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :hook (after-init . which-key-mode)
  :custom
  (which-key-idle-delay 0.5)
  :config
  (which-key-setup-minibuffer))
#+end_src

Make =ESC= quit wherever possible.

#+begin_src emacs-lisp :tangle yes
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

A handful of bindings inspired by Doom Emacs / Spacemacs.

#+begin_src emacs-lisp :tangle yes
(evil-set-leader 'normal (kbd "SPC"))

(defvar my-leader-map (make-sparse-keymap)
  "Keymap for \"leader key\" shortcuts.")

(define-key evil-normal-state-map (kbd "SPC") my-leader-map)
(define-key my-leader-map "b" 'list-buffers)
(define-key evil-normal-state-map (kbd "SPC h") help-map)
(define-key my-leader-map (kbd "RET") 'consult-bookmark)
(define-key my-leader-map "<" 'consult-buffer)
(define-key my-leader-map "z" 'consult-recent-file)
(define-key my-leader-map "," 'avy-goto-char-timer)
(define-key my-leader-map "." 'consult-line)
(define-key my-leader-map "x" 'consult-imenu)
;; Grep from all open buffers
(define-key my-leader-map "-" 'swiper-all)
#+end_src

A handful of must-have keybindings for me.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal 'global (kbd "ö") 'save-buffer)
(evil-define-key 'normal 'global (kbd "ä") 'delete-other-windows)
;; Grep across open buffers by setting "." as the file regex.
(evil-define-key 'normal 'global (kbd "M-ä") 'multi-occur-in-this-mode)
(evil-define-key 'normal 'global (kbd "C-ä") 'split-window-right)
(evil-define-key 'normal 'global (kbd "C-ö") 'split-window-below)
(evil-define-key 'normal 'global (kbd "Ö") 'xref-find-definitions)
(evil-define-key 'normal 'global (kbd "å") 'consult-yank-pop)
(evil-define-key 'normal 'global (kbd "Å") 'consult-org-heading)
(evil-define-key 'normal 'global (kbd "M-ö") 'evil-end-of-line) ;; $ is too unwieldy on a Scandinavian keyboard
(evil-define-key 'normal 'global (kbd "¨") 'evil-search-forward)

(evil-define-key 'normal 'global (kbd "C-j") 'evil-window-next)
(evil-define-key 'normal 'global (kbd "C-k") 'evil-window-prev)
(evil-define-key 'normal 'global (kbd "C-h") 'evil-window-left) ;; Yes! I did it, rebound C-h. SPC h in normal mode is the alternative.
(evil-define-key 'normal 'global (kbd "C-l") 'evil-window-right)
(evil-define-key 'insert 'global (kbd "C-j") 'evil-window-next)
(evil-define-key 'insert 'global (kbd "C-k") 'evil-window-prev)
(evil-define-key 'insert 'global (kbd "C-h") 'evil-window-left)
(evil-define-key 'insert 'global (kbd "C-l") 'evil-window-right)

(evil-define-key 'normal 'global (kbd "C-u") 'evil-scroll-up)
(evil-define-key 'normal 'global (kbd "DEL") 'paredit-splice-sexp)
(evil-define-key 'normal 'global (kbd "´") 'kill-buffer)
(evil-define-key 'normal 'global (kbd "C-M--") 'ibuffer)
(evil-define-key 'normal 'global (kbd "C-M--") 'ibuffer)
#+end_src

Bind a comfortable global key combination for =other-window= as =M-x o= is too long for such a common thing.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-o") #'other-window)
#+end_src

Prevent the "Text is read only" message when pressing backspace in minibuffer ([[https://emacs.stackexchange.com/questions/66589/how-to-prevent-text-is-read-only-when-in-minibuffer?newreg=e978077fa67744548d4395e6d7a973b5][source]]).

#+begin_src emacs-lisp :tangle yes
(defun backward-delete-char-stop-at-read-only (n &optional killflag)
  "Do as `backward-delete-char' but stop at read-only text."
  (interactive "p\nP")
  (unless (or (get-text-property (point) 'read-only)
          (eq (point) (point-min))
          (get-text-property (1- (point)) 'read-only))
    (setq n (min (- (point) (point-min)) n))
    (setq n (- (point) (previous-single-property-change (point) 'read-only nil (- (point) n))))
    (backward-delete-char n killflag)))

(define-key minibuffer-local-map (kbd "DEL") #'backward-delete-char-stop-at-read-only)
#+end_src

Frame management.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal 'global (kbd "M-§") 'other-frame)
(evil-define-key 'normal 'global (kbd "M-n") 'make-frame)
(evil-define-key 'normal 'global (kbd "M-°") 'delete-frame)
#+end_src

Window management. Source: [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][Mastering Emacs]].

#+begin_src emacs-lisp :tangle yes
(setq switch-to-buffer-obey-display-actions t)
(setq switch-to-buffer-in-dedicated-window 'pop)

(defun tv/toggle-window-dedication ()
  "Toggles window dedication in the selected window."
  (interactive)
  (set-window-dedicated-p (selected-window)
                          (not (window-dedicated-p (selected-window)))))
#+end_src

Easy buffer switching.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal 'global (kbd "C-M-l") 'next-buffer)
(evil-define-key 'normal 'global (kbd "C-M-h") 'previous-buffer)
#+end_src

Jump to previous positions from the mark ring by repeating the command.

#+begin_src emacs-lisp :tangle yes
(setq set-mark-command-repeat-pop t)
#+end_src

* AI

** Gptel

Let's try whether this could be useful. Gptel is a light-weight LLM client supporting multiple backends.

#+begin_src emacs-lisp :tangle yes
(use-package gptel
  :if work-laptop-p
  :ensure t
  :defer
  :config
  (setq
   gptel-model 'claude-3-7-sonnet-20250219
   gptel-backend (gptel-make-anthropic "Claude"
                   :stream t
                   :key (getenv "CLAUDE_API_KEY"))))
#+end_src

* Media playback

** Ready player mode

Trying [[https://github.com/xenodium/ready-player][this]] out. [[https://xenodium.com/a-tour-of-ready-player-mode][Seems]] like a nice way to play music and other media directly from Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package ready-player
  :ensure t
  :defer
  :custom
  (ready-player-my-media-collection-location "/Volumes/Musumusa/musa/Music/")
  (ready-player-ask-for-project-sustainability nil)
  (ready-player-hide-modeline nil)
  :bind (:map ready-player-minor-mode-map
              ("RET" . ready-player-menu))
  :config
  (when (memq system-type '(darwin))
    (set-fontset-font t nil "SF Pro Display" nil 'append)
    (ready-player-macos-use-sf-symbols)))
#+end_src

* Flycheck

#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :ensure t
  :defer
  :bind (:map flycheck-mode-map
              ("C-c C-n" . flycheck-next-error)
              ("C-c C-p" . flycheck-previous-error)))
#+end_src

* Ibuffer-projectile

Sort =ibuffer= by project.

#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-projectile
  :ensure t
  :hook (ibuffer-hook . (lambda ()
                          (ibuffer-projectile-set-filter-groups)
                          (unless (eq ibuffer-sorting-mode 'alphabetic)
                            (ibuffer-do-sort-by-alphabetic)))))
#+end_src


* Programming languages

** Bash

Use LSP when editing shell scripts.

#+begin_src emacs-lisp :tangle yes
(add-hook 'bash-ts-mode-hook #'lsp)
(setq sh-basic-offset 4)
#+end_src

[[https://github.com/bats-core/bats-core][Bats]] is a testing framework for Bash. =.bats=-files should be considered as Bash files.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.bats\\'" . bash-ts-mode))
#+end_src

** Clojure

Configure the necessary packages.

#+begin_src emacs-lisp :tangle yes
(use-package paredit
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
  ;; enable in the *scratch* buffer
  (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
  (add-hook 'lisp-mode-hook #'paredit-mode))

(defun initialize-kondo ()
  (dolist (checker '(clj-kondo-clj clj-kondo-cljs clj-kondo-cljc clj-kondo-edn))
    (setq flycheck-checkers (cons checker (delq checker flycheck-checkers)))))

(defun my-clojure-mode-hook ()
  (let ((modes (list #'paredit-mode #'subword-mode #'electric-pairs-mode
                     #'rainbow-delimiters-mode #'flycheck-mode
                     #'subword-mode)))
    (dolist (mode modes)
      (mode 1))))

(use-package clojure-mode
  :ensure t
  :config
  (define-clojure-indent
   (returning 1)
   (testing-dynamic 1)
   (testing-print 1)
   (POST 2)
   (GET 2)
   (PATCH 2)
   (PUT 2)))

(use-package inf-clojure
  :ensure t
  :config
  (add-hook 'inf-clojure-mode-hook #'paredit-mode)
  (add-hook 'inf-clojure-mode-hook #'rainbow-delimiters-mode))

(use-package cider
  :ensure t
  :config
  (setq nrepl-log-messages t)
  (add-hook 'cider-repl-mode-hook #'paredit-mode)
  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))

(defun my-cider-repl-mode-hook ()
  (paredit-mode 1)
  (evil-local-set-key 'insert (kbd "C-<return>") 'paredit-RET)
  (evil-local-set-key 'insert (kbd "RET") 'cider-repl-closing-return)
  (setq cider-repl-buffer-size-limit 20000))

(setq gc-cons-threshold (* 100 1024 1024)
      read-process-output-max (* 1024 1024)
      cider-font-lock-dynamically nil
      cider-repl-buffer-size-limit 1000
      ;; lsp-lens-enable nil ; Show the "1 references" etc text above definitions.
      ;; lsp-enable-indentation nil ; uncomment to use cider indentation instead of lsp
      ;; lsp-completion-enable nil ; uncomment to use cider completion instead of lsp
      )

(add-hook 'cider-repl-mode-hook #'my-cider-repl-mode-hook)
;; (add-hook 'clojure-ts-mode-hook #'my-clojure-mode-hook)

(add-hook 'clojurescript-mode-hook #'paredit-mode)
(add-hook 'clojurescript-mode-hook #'subword-mode)
(add-hook 'clojurescript-mode-hook #'flycheck-mode)
(add-hook 'clojurescript-mode-hook #'rainbow-delimiters-mode)
(add-hook 'clojurescript-mode-hook #'electric-pair-mode)
(add-hook 'clojure-mode-hook #'lsp)
(add-hook 'clojurescript-mode-hook #'lsp)
(add-hook 'clojure-mode-hook #'hs-minor-mode)
(add-hook 'clojurescript-mode-hook #'hs-minor-mode)
#+end_src

Configure [[https://github.com/ericdallo/jet.el][jet.el]].

#+begin_src emacs-lisp :tangle yes
(use-package jet
  :ensure t
  :defer)
#+end_src

Set keybindings.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal clojure-mode-map
  "°" #'cider-eval-buffer
  "§" #'cider-eval-defun-at-point
  "Ö" #'cider-find-var
  "q" #'cider-popup-buffer-quit
  "K" #'cider-doc)
#+end_src

** Haskell

Haskell configs. Locally remap the =font-lock-keyword-face= attribute, since slanted keywords (especially operators like pipes for guards) look silly in Haskell.

#+begin_src emacs-lisp :tangle yes
(use-package haskell-mode
  :ensure t
  :defer
  :hook ((haskell-mode . lsp)
         (haskell-mode . (lambda ()
                           (setq lsp-enable-completion-at-point nil)
                           (face-remap-add-relative 'font-lock-keyword-face nil :slant 'normal)))))

(use-package lsp-haskell
  :after haskell-mode
  :ensure t
  :defer)
#+end_src

** SQL

#+begin_src emacs-lisp :tangle yes
(setq sql-postgres-login-params nil)

(setq lsp-sqls-workspace-config-path nil)

(defun tv/maybe-highlight-ms-sql-kws ()
  "Highlight MS SQL keywords when it's certain that's the dialect we're
working with."
  (when (cl-search "umaija" (buffer-file-name))
    (sql-highlight-ms-keywords)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package sql
  :ensure t
  :hook ((sql-mode. lsp))
  :defer
  :config
  (setq lsp-sqls-workspace-config-path nil)
  (tv/maybe-highlight-ms-sql-kws))
#+end_src

Use [[https://github.com/alex-hhh/emacs-sql-indent][Emacs SQL indent]] minor mode.

#+begin_src emacs-lisp :tangle yes
(use-package sql-indent
  :ensure t
  :after sql
  :defer)
#+end_src

Sqlup-mode capitalizes SQL keywords automatically. Note that is has a [[https://github.com/Trevoke/sqlup-mode.el/issues/69][bug]] which might accidentally capitalize quoted strings. This has bitten me previously but I currently sometimes use this to format selections of SQL.

#+begin_src emacs-lisp :tangle yes
(use-package sqlup-mode
  :ensure t
  :after sql
  :defer)
#+end_src

Custom functions for formatting SQL code.

#+begin_src emacs-lisp :tangle yes
(defun tv/format-sql-buffer ()
  "Since there's some bug that breaks the indentation (`sqlind-indent-line`
specifically) when running it with `newline-and-indent`, I've resorted
to this hack to run the indentation and capitalization for the whole buffer."
  (interactive)
  (sqlind-minor-mode)
  (indent-region (point-min) (point-max))
  (sqlup-capitalize-keywords-in-buffer)
  (setq sqlind-minor-mode nil)
  (progn
    (kill-local-variable 'indent-line-function)
    (kill-local-variable 'align-mode-rules-list)))
#+end_src

** Emacs Lisp

Elisp keybindings.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal emacs-lisp-mode-map
  "°" 'eval-buffer
  "§" 'eval-defun)

(evil-define-key 'normal lisp-interaction-mode-map
  "°" 'eval-buffer
  "§" 'eval-defun)

(use-package ielm
  :config
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook #'(lambda ()
                                (setq-local corfu-auto nil)
                                (corfu-mode))))

(add-hook 'emacs-lisp-mode-hook #'(lambda ()
                                    (unless (string= (buffer-name) "*scratch*")
                                      (flycheck-mode))))
#+end_src

** Typescript

#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :ensure t
  :defer
  :custom
  (typescript-indent-level 2))
#+end_src

** Java

#+begin_src emacs-lisp :tangle yes
(use-package lsp-java :config (add-hook 'java-mode-hook 'lsp))
(use-package dap-mode :after lsp-mode :config (dap-auto-configure-mode))
(use-package dap-java :ensure nil)
#+end_src

** Python

#+begin_src emacs-lisp :tangle yes
(use-package python-black
  :ensure t
  :after python
  :hook ((python-mode . python-black-on-save-mode)
         (python-mode . lsp)
         (python-ts-mode . python-black-on-save-mode)
         (python-ts-mode . lsp))
  :config (setq lsp-pylsp-plugins-flake8-ignore '("D103" "D100" "D105")))

;; (add-hook 'python-mode-hook #'lsp)
;; (add-hook 'python-ts-mode-hook #'lsp)
#+end_src

** Groovy

#+begin_src emacs-lisp :tangle yes
(use-package groovy-mode
  :ensure t)
#+end_src

* LSP-mode

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :hook ((lsp-mode . lsp-enable-which-key-integration))
  :config (setq lsp-completion-enable-additional-text-edit nil
                lsp-lens-enable t
                lsp-auto-guess-root t
                lsp-headerline-breadcrumb-enable nil
                lsp-modeline-code-actions-enable t))
#+end_src

* Eldoc

#+begin_src emacs-lisp :tangle yes
(setq eldoc-echo-area-use-multiline-p nil)
#+end_src

* Verb

#+begin_src emacs-lisp :tangle yes
(use-package verb
  :ensure t
  :defer)
#+end_src

* No littering

#+begin_src emacs-lisp :tangle yes
(use-package no-littering
  :ensure t)
#+end_src

* Counsel-etags

This makes etags work, i.e. allows us to jump to definitions.

#+begin_src emacs-lisp :tangle yes
(use-package counsel-etags
  :ensure t
  :bind (("C-]" . counsel-etags-find-tag-at-point))
  :init
  (add-hook 'prog-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))
  :config
  (setq counsel-etags-update-interval 60)
  (push "build" counsel-etags-ignore-directories))
#+end_src

* Editorconfig

Pick up formatting settings from =.editorconfig= files.

#+begin_src emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src

* Ripgrep

Ripgrep package is needed for =projectile-ripgrep= to be usable.

#+begin_src emacs-lisp :tangle yes
(use-package ripgrep
  :ensure t
  :config
  (evil-define-key 'normal 'global "Ä" #'consult-ripgrep))
#+end_src

* Wgrep

Writable grep. This makes possible to use workflows for search and replace like:

1. Do a grep (e.g. =projectile-ripgrep=).
2. =wgrep-change-to-wgrep-mode= (or =i=).
3. =query-replace-regexp=

#+begin_src emacs-lisp :tangle yes
(use-package wgrep
  :ensure t
  :after evil-collection
  :config
  (evil-collection-define-key 'normal 'wgrep-mode-map
    "d" 'wgrep-mark-deletion
    "U" 'wgrep-remove-all-change))
#+end_src

* Completion

** Vertico

#+begin_src emacs-lisp :tangle yes
(use-package vertico
  :ensure t
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :init
  (vertico-mode)
  (setq vertico-cycle t))

(use-package vertico-multiform
  :ensure nil
  :hook (after-init . vertico-multiform-mode))
#+end_src

** Dabbrev

#+begin_src emacs-lisp :tangle yes
(use-package dabbrev
  :custom
  (dabbrev-upcase-means-case-search t)
  (dabbrev-check-all-buffers nil)
  (dabbrev-check-other-buffers t)
  (dabbrev-friend-buffer-function 'dabbrev--same-major-mode-p)
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src

** Corfu

#+begin_src emacs-lisp :tangle yes
(use-package corfu
  :ensure t
  ;; Optional customizations
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)               ;; Enable auto completion
  (corfu-auto-prefix 2)
  (corfu-auto-delay 0.4)
  (corfu-on-exact-match 'insert) ;; Insert when there's only one match
  (corfu-quit-no-match t)        ;; Quit when there is no bind
  :init
  (setq corfu-quit-at-boundary 'separator)
  (global-corfu-mode)
  (corfu-popupinfo-mode)
  (corfu-history-mode))

(use-package cape
  :ensure t
  :init
  (setq cape-dabbrev-min-length 2)
  (setq cape-dabbrev-check-other-buffers 'cape--buffers-major-mode)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-history)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)

  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input)
                (eq (current-local-map) read-passwd-map))
      (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
  :bind ("C-c SPC" . cape-dabbrev))

(use-package emacs
  :init
  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)
  ;; :hook ((prog-mode-hook . completion-preview-mode)
  ;;     (text-mode-hook . completion-preview-mode))
  ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  ;; (setq read-extended-command-predicate
  ;;       #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
#+end_src

Enable Corfu in minibuffers. Source: [[https://github.com/yantar92/emacs-config/blob/master/config.org][Ihor.]]

#+begin_src emacs-lisp :tangle yes
(use-package corfu
  :init
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer."
    (when (local-variable-p 'completion-at-point-functions)
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer))
#+end_src

** Orderless

#+begin_src emacs-lisp :tangle yes
(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle yes
(use-package consult
  :ensure t
  :bind (("C-å" . consult-line)
         ("C-c M-x" . consult-mode-command)
         ("C-x b" . consult-buffer)
         ("C-x r b" . consult-bookmark)
         ("M-y" . consult-yank-pop)
         ;; M-g bindings (goto-map)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("C-z" . consult-theme)
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history)
         :map prog-mode-map
         ("M-g o" . consult-imenu))

  :init
  (defun remove-items (x y)
    (setq y (cl-remove-if (lambda (item) (memq item x)) y))
    y)

  ;; Any themes that are incomplete/lacking don't work with centaur tabs/solair mode
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  (setq consult-narrow-key "<")
  (setq consult-line-start-from-top nil))
#+end_src

** Avy

#+begin_src emacs-lisp :tangle yes
(use-package avy
  :bind (("C-s" . avy-goto-char-timer)))
#+end_src

** Marginalia

#+begin_src emacs-lisp :tangle yes
(use-package marginalia
  :ensure
  :init
  (marginalia-mode))
#+end_src

** Embark

#+begin_src emacs-lisp :tangle yes
(use-package embark
  :ensure t

  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:

  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; (setq prefix-help-command #'embark-prefix-help-command)

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Yasnippet

Yasnippets are very handy, and Doom Emacs contains a nice bundle of them.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :diminish yas-minor-mode
  :init (yas-global-mode)
  :config
  (push '(yasnippet backquote-change) warning-suppress-types)
  (yas-global-mode)
  (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  (setq yas-key-syntaxes '("w_" "w_." "^ "))
  (setq yas-installed-snippets-dir ".config/emacs/etc/snippets")
  (setq yas-expand-only-for-last-commands nil)
  (yas-global-mode 1)
  (bind-key "\t" 'hippie-expand yas-minor-mode-map))

(use-package doom-snippets
  :if (file-directory-p "~/dev/snippets")
  :load-path "~/dev/snippets"
  :after yasnippet)
#+end_src

* History

** Save-place-mode

Remember and restore the last cursor location of opened files.

#+begin_src emacs-lisp :tangle yes
(use-package saveplace
  :config
  (setq save-place-file (expand-file-name "saveplace" tv-savefile-dir))
  ;; activate it for all buffers
  (setq-default save-place t))
#+end_src

** Savehist-mode

Remember where we were in the minibuffer.

#+begin_src emacs-lisp :tangle yes
(use-package savehist
  :config
  (setq savehist-additional-variables
        ;; search entries
        '() ;;'(search-ring regexp-search-ring kill-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        history-length 25
        savehist-save-minibuffer-history 1
        savehist-file (expand-file-name "savehist" tv-savefile-dir))
  (savehist-mode +1))
#+end_src

** Recentf-mode

Enable =recentf-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :init (recentf-mode 1)
  :config
  (setq recentf-save-file (expand-file-name "recentf" tv-savefile-dir)
        recentf-max-saved-items 40
        recentf-max-menu-items 40
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never))
#+end_src

* File formats

** Docker

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :ensure t
  :defer)

(use-package docker
  :ensure t
  :defer
  :bind ("C-c d" . docker))
#+end_src

** Markdown

#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t
  :hook (markdown-mode . display-line-numbers-mode)
  :mode ("README\\.md\\'" . gfm-mode)
  :init (setq markdown-command "multimarkdown"))
#+end_src

** YAML

#+begin_src emacs-lisp :tangle yes
(use-package yaml-ts-mode
  :ensure nil
  :hook (yaml-ts-mode . display-line-numbers-mode)
  :mode
  ("\\.yml\\'" . yaml-ts-mode)
  ("\\.yaml\\'" . yaml-ts-mode))
#+end_src

** XML

Use 4 spaces as the default indentation level.

#+begin_src emacs-lisp :tangle yes
(add-hook 'nxml-mode-hook #'display-line-numbers-mode)
(setq nxml-child-indent 4 nxml-attribute-indent 4)
#+end_src

* Org mode

#+begin_src emacs-lisp :tangle yes
(use-package org
  :ensure nil
  :bind
  (("C-c c" . org-capture)
   ("C-c l" . org-store-link))
  :custom
  (fill-column 100)
  ;; Disable the underscore-to-subscript thing.
  (org-pretty-entities t)
  (org-log-done 'time)
  (org-log-into-drawer nil)
  (org-use-sub-superscripts "{}")
  (org-fold-catch-invisible-edits 'error)
  (org-todo-keywords
   '((sequence "TODO(t)" "HOLD(h@/!)" "DOING(g)" "|" "DONE(d)" "KILL(k)")
     (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
     (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))
  (org-done ((t (:foreground "PaleGreen"
                             :strike-through t))))
  (org-tags-column 0)
  (org-todo-keyword-faces
   '(("AREA"         . "DarkOrchid1")
     ("[AREA]"       . "DarkOrchid1")
     ("PROJECT"      . "DarkOrchid1")
     ("[PROJECT]"    . "DarkOrchid1")
     ("INBOX"        . "cyan")
     ("[INBOX]"      . "cyan")
     ("PROPOSAL"     . "orange")
     ("[PROPOSAL]"   . "orange")
     ("DRAFT"        . "yellow3")
     ("[DRAFT]"      . "yellow3")
     ("INPROGRESS"   . "yellow4")
     ("[INPROGRESS]" . "yellow4")
     ("MEETING"      . "purple")
     ("[MEETING]"    . "purple")
     ("CANCELED"     . "blue")
     ("[CANCELED]"   . "blue")))
  :config
  (custom-set-faces
   '(org-document-title ((t (:inherit outline-1 :height 1.50))))
   '(org-level-1 ((t (:inherit outline-1 :height 1.30))))
   '(org-level-2 ((t (:inherit outline-2 :height 1.15))))
   '(org-level-3 ((t (:inherit outline-3 :height 1.15))))
   '(org-level-4 ((t (:inherit outline-4 :height 1.15))))
   '(org-level-5 ((t (:inherit outline-5 :height 1.10))))
   '(org-level-6 ((t (:inherit outline-6 :height 1.05))))
   '(org-level-7 ((t (:inherit outline-7 :height 1.00)))))
  (define-key org-mode-map (kbd "C-c C-r") verb-command-map)
  (evil-define-key 'normal org-mode-map
    (kbd "M-l") #'org-metaright
    (kbd "M-h") #'org-metaleft
    (kbd "M-k") #'org-metaup
    (kbd "M-j") #'org-metadown
    (kbd "M-L") #'org-shiftmetaright
    (kbd "M-H") #'org-shiftmetaleft
    (kbd "M-K") #'org-shiftmetaup
    (kbd "M-J") #'org-shiftmetadown
    (kbd "§") #'verb-send-request-on-point-other-window-stay)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-insert-heading-respect-content t)
  (setq org-directory "~/Dropbox/org/")
  (setq org-default-notes-file (concat org-directory "inbox.org"))
  (setq org-work-notes-file (concat org-directory "work.org"))
  (setq org-archive-location "archive/Archive_%s::")
  (setq org-ellipsis " ▾")
  (setq org-src-fontify-natively t)
  (setq org-superstar-headline-bullets-list '("› "))
  (setq org-agenda-start-with-log-mode t)
  (setq org-cycle-emulate-tab nil)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sql . t)
     (sqlite . t)
     (python . t)
     (java . t)
     (C . t)
     (emacs-lisp . t)
     (clojure . t)
     (shell . t)))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        org-indent-mode nil)
  (setq org-capture-templates
        '(("f" "Fleeting note" item
           (file+headline org-default-notes-file "Notes")
           "- %?"
           :jump-to-captured t)
          ("p" "Permanent note" plain
           (file denote-last-path)
           #'denote-org-capture
           :no-save t
           :immediate-finish nil
           :kill-buffer t
           :jump-to-captured t)
          ("t" "New task" entry
           (file+headline org-default-notes-file "Tasks")
           "* TODO %i%?")
          ("v" "Video link" entry
           (file+headline "notes/20221110T100214--katsottavia-videoita__linkit_videot_youtube.org" "Inbox")
           "* [[%^{Video URL}][%^{Video title}]]")
          ("j" "Journal entry" entry
           (file+datetree "dailies.org" "week")
           "* %<%H:%M> %?"
           :jump-to-captured t)))
  ;; Export settings
  (setq org-export-with-toc nil)  ; No table of contents
  (setq org-export-with-section-numbers nil)  ; No section numbers
  (setq org-export-with-smart-quotes t)  ; Use smart quotes
  (setq org-export-with-sub-superscripts nil)  ; No superscripts
  ;; https://github.com/zzamboni/dot-emacs/blob/master/init.org
  :hook ((org-mode . visual-line-mode)
         ;;(org-mode . org-indent-mode)
         ))

;; From elken

(defun tv/org-archive-done-tasks ()
  "Attempt to archive all done tasks in file"
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
   "/DONE" 'file))

(defun tv/org-remove-kill-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-cut-subtree)
     (pop kill-ring)
     (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
   "/KILL" 'file))

(evil-define-key 'normal org-mode-map
  (kbd "C-c DEL a") #'tv/org-archive-done-tasks
  (kbd "C-c DEL k") #'tv/org-remove-kill-tasks)

(use-package hl-todo
  :ensure t
  :defer
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode)))

(use-package org-appear
  :ensure t
  :defer
  :after org
  :custom
  (org-appear-autoemphasis t)
  (org-appear-autosubmarkers t)
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-hide-emphasis-markers t)  ;; Must be activated for org-appear to work
  (setq org-appear-autoemphasis   t   ;; Show bold, italics, verbatim, etc.
        org-appear-autolinks      nil   ;; Show links
        org-appear-autosubmarkers t))
           #+end_src

** Evil-org

#+begin_src emacs-lisp :tangle yes
(use-package evil-org
  :ensure t
  :after org
  :hook (org-mode . evil-org-mode)
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)

  (defun tv/org-todo-toggle-or-open-link ()
    "Open link or toggle a TODO, depending on which one is under point."
    (interactive)
    (let ((type (car (org-element-context))))
      (if (eq 'link type)
          (org-open-at-point)
        (progn
          (let ((state (org-get-todo-state)))
            (message state)
            (cond
             ((string= state "TODO") (org-todo "DOING"))
             ((string= state "DOING") (org-todo "DONE"))
             ((string= state "DONE") (org-todo "TODO"))))))))

  (evil-define-key 'normal org-mode-map
    (kbd "RET") #'tv/org-todo-toggle-or-open-link))
#+end_src

** Denote

I use =denote= for note taking and personal knowledge management. I migrated from =org-roam= to =denote= mostly due to the slow database indexing - after importing about 1200 notes from my IMDB watchlist, the indexing started taking minutes. Denote does not use a database, which is a huge plus in my book.

#+begin_src emacs-lisp :tangle yes
(use-package denote
  :defer t
  :ensure t
  :init
  (denote-rename-buffer-mode 1) ;; This seems to cause freezes when trying to open files. EDIT: Maybe not anymore, trying it out again.
  :custom-face
  (denote-faces-link ((t (:slant italic))))
  :hook
  (dired-mode . denote-dired-mode)
  :config
  (setq denote-directory (concat org-directory "notes"))
  (setq denote-backlinks-show-context nil)
  :bind (:map global-map
              (("C-c n b" . denote-find-backlink)
               ("C-c n d" . denote-create-note)
               ("C-c n d" . denote-date)
               ("C-c n F" . denote-find-link)
               ("C-c n h" . denote-org-extras-link-to-heading)
               ("C-c n i" . denote-open-or-create)
               ("C-c n k" . denote-rename-file-keywords)
               ("C-c n r" . denote-rename-file)
               ("C-c n R" . tv/denote-dired-rename-files-prompt-only-title)
               ("C-c n l" . denote-link-or-create)
               ("C-c n L" . denote-link-after-creating)
               ("C-c n n" . denote-create-note)
               ("C-c n N" . denote-create-note-with-template))))

(use-package consult-notes
  :ensure t
  :commands (consult-notes
             consult-notes-search-in-all-notes)
  :custom
  (consult-notes-file-dir-sources
   `(("Denote" ?d ,denote-directory)))
  :bind (:map global-map
              (("C-c n f" . consult-notes)
               ("C-c n s" . consult-notes-search-in-all-notes))))
#+end_src

** Denote extensions

*** Consult-denote

#+begin_src emacs-lisp :tangle yes
(use-package consult-denote
  :ensure t
  :bind (:map global-map
              (("C-c n g" . consult-denote-grep))))
#+end_src

*** Denote-org

#+begin_src emacs-lisp :tangle yes
(use-package denote-org
  :ensure t)
#+end_src

*** Denote-journal

Just trying this one out for now.

#+begin_src emacs-lisp :tangle yes
(use-package denote-journal
  :ensure t)
#+end_src

*** Denote-sequence

Just trying this one out for now.

#+begin_src emacs-lisp :tangle yes
(use-package denote-sequence
  :ensure t)
#+end_src

** Denote-explore

Modified from [[https://github.com/pprevos/emacs-writing-studio/blob/master/init.el][Emacs Writing Studio]].

#+begin_src emacs-lisp :tangle yes
(use-package denote-explore
  :bind
  (;; Statistics
   ("C-c w x c" . denote-explore-count-notes)
   ("C-c w x C" . denote-explore-count-keywords)
   ;; Denote Janitor
   ("C-c w x d" . denote-explore-duplicate-notes)
   ("C-c w x z" . denote-explore-zero-keywords)
   ("C-c w x s" . denote-explore-single-keywords)
   ("C-c w x o" . denote-explore-sort-keywords)
   ("C-c w x w" . denote-explore-rename-keyword)
   ;; Visualise denote
   ("C-c w x n" . denote-explore-network)
   ("C-c w x v" . denote-explore-network-regenerate)
   ("C-c w x D" . denote-explore-degree-barchart)))
#+end_src

** Custom Denote functions

*** Renaming files

I need a variant of =denote-dired-rename-files= that doesn't prompt for input.

#+begin_src emacs-lisp :tangle yes
(defun tv/denote-dired-rename-files-without-prompting ()
  "Rename Dired marked files same way as `denote-rename-file'.
Rename each file in sequence, making all the relevant prompts.
Unlike `denote-rename-file', do not prompt for confirmation of
the changes made to the file: perform them outright (same as
setting `denote-rename-confirmations' to a nil value)."
  (declare (interactive-only t))
  (interactive nil dired-mode)
  (let ((denote--used-ids (denote--get-all-used-ids))
        (denote-rename-confirmations nil))
    (if-let* ((marks (dired-get-marked-files)))
        (progn
          (dolist (file marks)
            (pcase-let ((`(,title ,keywords ,signature ,date)
                         (tv/denote--rename-get-file-info-from-existing file)))
              (denote--rename-file file title keywords signature date)))
          (denote-update-dired-buffers))
      (user-error "No marked files; aborting"))))

(defun tv/denote--rename-get-file-info-from-existing (file)
  "Retrieve existing info from FILE without prompting.

It is meant to be combined with `denote--rename-file' to create
renaming commands."
  (let* ((file-in-prompt (propertize (file-relative-name file) 'face 'denote-faces-prompt-current-name))
         (file-type (denote-filetype-heuristics file))
         (id (or (denote-retrieve-filename-identifier file) ""))
         (date (or (denote-valid-date-p id) (denote--generate-date-for-rename file)))
         (title (or (denote-retrieve-title-or-filename file file-type) ""))
         (keywords (denote-extract-keywords-from-path file))
         (signature (or (denote-retrieve-filename-signature file) "")))
    (list title keywords signature date)))
#+end_src

What I also need is a function to rename multiple files with the same name, without keywords. Here, a title is prompted once and the marked files are renamed using the input.

#+begin_src emacs-lisp :tangle yes
(defun tv/denote-dired-rename-files-prompt-only-title ()
  "Rename Dired marked files same way as `denote-rename-file'.
Rename each file in sequence, only prompting for title.
Unlike `denote-rename-file', do not prompt for confirmation of
the changes made to the file: perform them outright (same as
setting `denote-rename-confirmations' to a nil value)."
  (declare (interactive-only t))
  (interactive nil dired-mode)
  (let ((denote--used-ids (denote--get-all-used-ids))
        (denote-rename-confirmations nil)
        (title ""))
    (if-let* ((marks (dired-get-marked-files)))
        (progn
          (dolist (file marks)
            (when (string= title "")
              (setq title (denote-title-prompt
                           title
                           (format "Rename `%s' with TITLE (empty to remove)"
                                   (propertize (file-relative-name file) 'face 'denote-faces-prompt-current-name)))))
            (denote--rename-file file title (denote-extract-keywords-from-path file) "" (denote--generate-date-for-rename file)))
          (denote-update-dired-buffers))
      (user-error "No marked files; aborting"))))
#+end_src

*** Align front matter

Re-indent front-matter. Could be handy if a key longer than the stock ones has been added. Used AI (Claude) for this one.

#+begin_src emacs-lisp :tangle yes
(defun tv/align-org-front-matter ()
  "Align key-value pairs in Org Mode front matter."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((front-matter-end (save-excursion
                              (re-search-forward "^\\($\\|[^#]\\)" nil t)
                              (point)))
          (keys nil))
      ;; First pass: collect all keys and find max length
      (while (re-search-forward "^#\\+\\([A-Za-z_]+\\):" front-matter-end t)
        (push (match-string-no-properties 1) keys))
      (when keys
        (let ((max-length (apply #'max (mapcar #'length keys))))
          ;; Second pass: realign all front matter
          (goto-char (point-min))
          (while (re-search-forward "^#\\+\\([A-Za-z_]+\\):\\s-*\\(.*\\)" front-matter-end t)
            (let* ((key (match-string-no-properties 1))
                   (val (match-string-no-properties 2))
                   (padding (- (+ max-length 1) (length key))))
              (replace-match (format "#\+%s:%s%s"
                                     key
                                     (make-string padding ?\s)
                                     val))))))))
  (message "Front matter aligned."))
#+end_src

** Org Agenda
:PROPERTIES:
:ID:       DB9E54AF-CBBB-4C0E-B54E-A3EF408626A4
:END:

#+begin_src emacs-lisp :tangle yes
(use-package org-agenda
  :after org
  :ensure nil
  :bind (("C-c a" . org-agenda))
  ;; :hook (org-agenda-finalize . org-agenda-entry-text-mode)
  :custom
  (org-agenda-current-time-string (if (and (display-graphic-p)
                                           (char-displayable-p ?←)
                                           (char-displayable-p ?─))
                                      "← now"
                                    "now - - - - - - - - - - - - - - - - - - - - - - - - -"))
  (org-agenda-timegrid-use-ampm t)
  (org-agenda-tags-column 0)
  (org-agenda-window-setup 'only-window)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-log-mode-items '(closed clock state))
  (org-agenda-time-grid '((daily today require-timed)
                          (600 800 1000 1200 1400 1600 1800 2000)
                          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  ;; (org-agenda-start-with-log-mode '(closed clock state))
  ;; (org-agenda-files (list org-default-notes-file))
  (org-agenda-files (list org-directory))
  ;; (org-agenda-todo-ignore-scheduled 'future)
  ;; TODO entries that can't be marked as done b/c of children are shown as dimmed in agenda view
  (org-agenda-dim-blocked-tasks 'invisible)
  ;; Start the week view on whatever day im on
  (org-agenda-start-on-weekday nil)
  ;; How to identify stuck/non-stuck projects
  ;; Projects are identified by the 'project' tag and its always the first level
  ;; Next any of these todo keywords means it's not a stuck project
  ;; 3rd, theres no tags that I use to identify a stuck Project
  ;; Finally, theres no special text that signify a non-stuck project
  (org-stuck-projects
   '("+project+LEVEL=1"
     ("IN-PROGRESS" "WAITING" "DONE" "CANCELED" "DELEGATED")
     nil
     ""))
  (org-agenda-prefix-format
   '((agenda . " %-4e %i %-12:c%?-12t% s ")
     (todo . " %i %-10:c %-5e %(get-schedule-or-deadline-if-available)")
     (tags . " %i %-12:c")
     (search . " %i %-12:c")))
  ;; Lets define some custom cmds in agenda menu
  (org-agenda-custom-commands
   '(("h" "Agenda and Home tasks"
      ((agenda "" ((org-agenda-span 2)))
       (todo "WAITING|IN-PROGRESS")
       (tags-todo "inbox|break")
       (todo "NEXT"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("w" "Agenda and break|inbox tasks"
      ((agenda "" ((org-agenda-span 1)))
       (tags-todo "inbox|break"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("i" "In-Progress Tasks"
      ((todo "IN-PROGRESS|WAITING")
       (agenda ""))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("g" "Goals: 12 Week Year"
      ((agenda "")
       (todo "IN-PROGRESS|WAITING"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))
       (org-agenda-tag-filter-preset '("+12WY"))
       (org-agenda-start-with-log-mode '(closed clock state))
       (org-agenda-archives-mode t)
       ))))
  :init
  ;; Originally from here: https://stackoverflow.com/a/59001859/2178312
  (defun get-schedule-or-deadline-if-available ()
    (let ((scheduled (org-get-scheduled-time (point)))
          (deadline (org-get-deadline-time (point))))
      "   ")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package org-present
  :ensure t
  :defer)
#+end_src

Enable dragging and dropping images to org documents. Note that the command-line utility =pngpaste= must be installed for this to work.

#+begin_src emacs-lisp :tangle yes
(use-package org-download
  :ensure t
  :config
  (setq-default org-download-image-dir (concat org-directory "assets")))
#+end_src

** Org-modern mode

#+begin_src emacs-lisp :tangle yes
(use-package org-modern
  :ensure t)
#+end_src

** Copy articles from web to org

#+begin_src emacs-lisp :tangle yes
(use-package org-web-tools
  :ensure t)
#+end_src

From [[https://www.reddit.com/r/emacs/comments/1lnhtbs/how_do_you_store_and_revisit_articles_from_web/][Emacs Reddit]].

#+begin_src emacs-lisp :tangle yes
(defun tv/eww-to-org (&optional dest)
  "Render the current eww buffer using org markup.
  If DEST, a buffer, is provided, insert the markup there."
  (interactive)
  (unless (org-region-active-p)
    (let ((shr-width 80)) (eww-readable)))
  (let* ((start (if (org-region-active-p) (region-beginning) (point-min)))
         (end (if (org-region-active-p) (region-end) (point-max)))
         (buff (or dest (generate-new-buffer "*eww-to-org*")))
         (link (eww-current-url))
         (title (or (plist-get eww-data :title) "")))
    (with-current-buffer buff
      (insert "#+title: " title "\n#+link: " link "\n\n")
      (org-mode))
    (save-excursion
      (goto-char start)
      (while (< (point) end)
        (let* ((p (point))
               (props (text-properties-at p))
               (k (seq-find (lambda (x) (plist-get props x))
                            '(shr-url image-url outline-level face)))
               (prop (and k (list k (plist-get props k))))
               (next (if prop
                         (next-single-property-change p (car prop) nil end)
                       (next-property-change p nil end)))
               (txt (buffer-substring (point) next))
               (txt (replace-regexp-in-string "\\*" "·" txt)))
          (with-current-buffer buff
            (insert
             (pcase prop
               ((and (or `(shr-url ,url) `(image-url ,url))
                     (guard (string-match-p "^http" url)))
                (let ((tt (replace-regexp-in-string "\n\\([^$]\\)" " \\1" txt)))
                  (org-link-make-string url tt)))
               (`(outline-level ,n)
                (concat (make-string (- (* 2 n) 1) ?*) " " txt "\n"))
               ('(face italic) (format "/%s/ " (string-trim txt)))
               ('(face bold) (format "*%s* " (string-trim txt)))
               (_ txt))))
          (goto-char next))))
    (pop-to-buffer buff)
    (goto-char (point-min))))
#+end_src

** Org-friendly word counting

Source: [[https://chrismaiorana.com/summer-productivity-reset-emacs-functions/][Chris Maiorana]].

#+begin_src emacs-lisp :tangle yes
(defun org-word-count ()
  "Count words in region/buffer, estimate pages, and reading time.
Excludes lines beginning with * or #. Prints result in echo area."
  (interactive)
  (let* ((start (if (use-region-p) (region-beginning) (point-min)))
         (end (if (use-region-p) (region-end) (point-max)))
         (word-count
          (save-excursion
            (goto-char start)
            (let ((count 0)
                  (inhibit-field-text-motion t))
              (while (< (point) end)
                (beginning-of-line)
                (unless (looking-at-p "^[*#<]")
                  (let ((line-end (line-end-position)))
                    (while (re-search-forward "\\w+\\W*" line-end t)
                      (setq count (1+ count)))))
                (forward-line 1))
              count)))
         (words-per-page 400)
         (reading-speed 215)
         (page-count (/ (+ word-count words-per-page -1) words-per-page))
         (reading-time (/ (+ word-count reading-speed -1) reading-speed)))
    (message "%d words, ~%d pages, ~%d min read"
             word-count page-count reading-time)))
#+end_src

* Elfeed

RSS feeds are a convenient way to consume information on a pull-basis from different sources. I can't be bothered to tweak the stock elfeed experience too much.

#+begin_src emacs-lisp :tangle yes
(use-package elfeed
  :defer
  :ensure t
  :init
  (elfeed-org)
  :config
  (setq elfeed-search-filter "@2-week-ago +unread")
  (evil-define-key 'normal elfeed-search-mode-map
    (kbd "M-RET") #'elfeed-search-browse-url
    (kbd "DEL") #'tv/elfeed-mark-read
    (kbd "M-DEL") #'tv/elfeed-mark-all-as-read
    "§" #'elfeed-update))

(use-package elfeed-org
  :defer
  :ensure t
  :config
  (setq rmh-elfeed-org-files (list "~/elfeed.org")))

(defun tv/elfeed-mark-all-as-read ()
  "Mark all elfeed items as read."
  (interactive)
  (when (equal 'elfeed-search-mode major-mode)
    (elfeed-untag elfeed-search-entries 'unread)
    (elfeed-search-update :force)))

(defun tv/elfeed-mark-read (entry)
  "Display the currently selected item in a buffer."
  (interactive (list (elfeed-search-selected :ignore-region)))
  (when (elfeed-entry-p entry)
    (elfeed-untag entry 'unread)
    (elfeed-search-update-entry entry)
    (unless elfeed-search-remain-on-entry (forward-line))))

(defun tv/elfeed-kill-buffers ()
  "Kill elfeed buffer and the elfeed.org feed definition buffer."
  (interactive)
  (let ((buffer (get-buffer "elfeed.org")))
    (kill-buffer buffer)
    (elfeed-kill-buffer)))
#+end_src

* Shell stuff

** General

Use ansi-colors in shell.

#+begin_src emacs-lisp :tangle yes
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

** Eshell

#+begin_src emacs-lisp :tangle yes
(use-package eshell
  :after quotient
  :hook ((eshell-mode . hide-mode-line-mode)
         (eshell-mode . (lambda ()
                          (setenv "TERM" "xterm-256color")
                          (setq eshell-banner-message (quotient-generate-quote 'eshell))
                          (setq-local completion-styles '(basic))
                          (setq-local corfu-count 10)
                          (setq-local corfu-auto nil)
                          (setq-local corfu-preview-current nil)
                          (setq-local completion-at-point-functions '(pcomplete-completions-at-point cape-file)))))
  :init
  (setq eshell-scroll-to-bottom-on-input 'all
        eshell-banner-message (quotient-generate-quote 'eshell)
        eshell-error-if-no-glob t
        eshell-hist-ignoredups t
        evil-set-initial-state 'insert
        eshell-save-history-on-exit t
        eshell-prefer-lisp-functions nil
        eshell-directory-name (expand-file-name "etc/eshell" user-emacs-directory)
        eshell-destroy-buffer-when-process-dies t))
#+end_src

Eshell aliases.

#+begin_src emacs-lisp :tangle yes
(setq tv/eshell-aliases
      '((g  . magit)
        (gl . magit-log)
        (d  . dired)
        (c  . clear)
        (cl  . clear)
        (o  . find-file)
        (ff  . find-file)
        (oo . find-file-other-window)
        (l  . (lambda () (eshell/ls '-la)))))

(mapc (lambda (alias)
        (defalias (car alias) (cdr alias)))
      tv/eshell-aliases)
#+end_src

Use syntax highlighting in =eshell=.

#+begin_src emacs-lisp :tangle yes
(use-package eshell-syntax-highlighting
  :ensure t
  :config
  (eshell-syntax-highlighting-global-mode +1)
  :init
  (defface eshell-syntax-highlighting-invalid-face
    '((t :inherit diff-error))
    "Face used for invalid Eshell commands."
    :group 'eshell-syntax-highlighting))
#+end_src

Eshell-autosuggest.

#+begin_src emacs-lisp :tangle yes
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode)
  :ensure t)
#+end_src

Copied from [[https://github.com/abrochard/emacs-config/blob/master/configuration.org][abrochard]].

#+begin_src emacs-lisp :tangle yes
(defun tv/eshell-here ()
  "Opens up a new shell in the directory associated with the
    current buffer's file. The eshell is renamed to match that
    directory to make multiple eshell windows easier."
  (interactive)
  (let* ((height (/ (window-total-height) 3)))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (insert (concat "ls"))
    (eshell-send-input)))

(bind-key "C-!" 'tv/eshell-here)
#+end_src

Jump around directories quickly. From [[https://karthinks.com/software/jumping-directories-in-eshell/][Karthinks]].

#+begin_src emacs-lisp :tangle yes
(defun eshell/z (&optional regexp)
  "Navigate to a previously visited directory in eshell, or to
any directory proferred by `consult-dir'."
  (let ((eshell-dirs (delete-dups
                      (mapcar 'abbreviate-file-name
                              (ring-elements eshell-last-dir-ring)))))
    (cond
     ((and (not regexp) (featurep 'consult-dir))
      (let* ((consult-dir--source-eshell `(:name "Eshell"
                                                 :narrow ?e
                                                 :category file
                                                 :face consult-file
                                                 :items ,eshell-dirs))
             (consult-dir-sources (cons consult-dir--source-eshell
                                        consult-dir-sources)))
        (eshell/cd (substring-no-properties
                    (consult-dir--pick "Switch directory: ")))))
     (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                     (completing-read "cd: " eshell-dirs)))))))
    #+end_src

** Vterm

#+begin_src emacs-lisp :tangle yes
(use-package vterm
  :hook ((vterm-mode . hide-mode-line-mode)
         (vterm-mode . (lambda () (setq-local global-hl-line-mode nil))))
  :ensure t
  :defer
  :custom
  (vterm-max-scrollback 100000)
  :config
  (setq vterm-shell "/bin/zsh")
  (setq vterm-kill-buffer-on-exit t)
  (setq vterm-max-scrollback 100000)
  (setq vterm-keymap-exceptions nil))
#+end_src

* Configure epg-pinentry-mode

This is needed for =pass= and =epa=.

#+begin_src emacs-lisp :tangle yes
(setq epg-pinentry-mode 'loopback)
#+end_src

* Pass

Use the =pass= package to interact with the similarly named Linux password manager.

#+begin_src emacs-lisp :tangle yes
(use-package pass
  :ensure t
  :defer t
  :config
  (require 'auth-source-pass)
  (auth-source-pass-enable))
#+end_src


* File info

Show information about the file under editing.

#+begin_src emacs-lisp :tangle yes
(use-package file-info
  :ensure t
  :bind (("C-c f" . 'file-info-show)))
#+end_src

* EWW

Disable images.

#+begin_src emacs-lisp :tangle yes
(setq shr-inhibit-images t)
#+end_src

* Dired

#+begin_src emacs-lisp :tangle yes
(use-package dired
  :ensure nil
  :defer t
  :hook ((dired-mode . dired-hide-details-mode)
         (dired-mode . hl-line-mode)
         (dired-mode . ready-player-mode))
  :bind (:map dired-mode-map
              ("C-c C-e" . wdired-change-to-wdired-mode))
  :custom
  (dired-kill-when-opening-new-dired-buffer t) ;; Without this, each directory level opens in its own buffer.
  (dired-do-revert-buffer t)
  (dired-auto-revert-buffer t)
  (delete-by-moving-to-trash t)
  (dired-mouse-drag-files t)
  (dired-dwim-target t)
  :config
  (setq dired-listing-switches "-alFh")
  (setq dired-use-ls-dired nil)
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
  (setq dired-dwim-target t)
  (evil-define-key 'normal 'global (kbd "C-M-ä") 'dired-jump))

(use-package diredfl
  :ensure t
  :hook (after-init . diredfl-global-mode))

(use-package all-the-icons-dired
  :ensure t
  :defer
  :hook (dired-mode . all-the-icons-dired-mode)
  :custom
  (all-the-icons-dired-monochrome nil))
#+end_src

Install [[https://github.com/Fuco1/dired-narrow][dired-narrow]].

#+begin_src emacs-lisp :tangle yes
(use-package dired-narrow
  :ensure t)
#+end_src

* Show diff for unsaved changes

When there are unsaved changes and the user tries to exit Emacs, it asks whether I want to save them. With this snippet in the config, it also shows /what/ the said changes are, which should be helpful.

Found this [[https://eugene-andrienko.com/en/it/2025/06/30/my-emacs-configuration-common.html#rc-emacs-cursor-minibuffer][here]].

#+begin_src emacs-lisp :tangle yes
                                        ; If asked to save buffer on C-x C-c - show diff of changes with d key
(add-to-list 'save-some-buffers-action-alist
             '("d" (lambda (buffer)
                     (diff-buffer-with-file (buffer-file-name buffer)))
               "Show diff of changes"))
#+end_src

* Transient

Modified from [[https://github.com/gopar/.emacs.d][Gopar]].

#+begin_src emacs-lisp :tangle yes
(use-package transient
  :ensure t
  :bind ("C-M-o" . windows-transient-window)
  :config
  (transient-define-prefix windows-transient-window ()
    "Display a transient buffer showing useful window manipulation bindings."
    [["Resize"
      ("}" "h+" enlarge-window-horizontally :transient t)
      ("{" "h-" shrink-window-horizontally :transient t)
      ("^" "v+" enlarge-window :transient t)
      ("V" "v-" shrink-window :transient t)]
     ["Split"
      ("v" "vertical" (lambda ()
                        (interactive)
                        (split-window-right)
                        (windmove-right)) :transient t)
      ("x" "horizontal" (lambda ()
                          (interactive)
                          (split-window-below)
                          (windmove-down)) :transient t)
      ("wv" "win-vertical" (lambda ()
                             (interactive)
                             (select-window (split-window-right))
                             (windows-transient-window)) :transient nil)
      ("wx" "win-horizontal" (lambda ()
                               (interactive)
                               (select-window (split-window-below))
                               (windows-transient-window)) :transient nil)]
     ["Misc"
      ("B" "switch buffer" (lambda ()
                             (interactive)
                             (consult-buffer)
                             (windows-transient-window)))
      ("z" "undo" (lambda ()
                    (interactive)
                    (winner-undo)
                    (setq this-command 'winner-undo)) :transient t)
      ("Z" "redo" winner-redo :transient t)]]
    [["Move"
      ("h" "←" windmove-left :transient nil)
      ("j" "↓" windmove-down :transient nil)
      ("l" "→" windmove-right :transient nil)
      ("k" "↑" windmove-up :transient nil)]
     ["Swap"
      ("sh" "←" windmove-swap-states-left :transient t)
      ("sj" "↓" windmove-swap-states-down :transient t)
      ("sl" "→" windmove-swap-states-right :transient t)
      ("sk" "↑" windmove-swap-states-up :transient t)]
     ["Delete"
      ("dh" "←" windmove-delete-left :transient t)
      ("dj" "↓" windmove-delete-down :transient t)
      ("dl" "→" windmove-delete-right :transient t)
      ("dk" "↑" windmove-delete-up :transient t)
      ("D" "This" delete-window :transient t)]
     ["Transpose"
      ("tt" "↜" (lambda ()
                  (interactive)
                  (transpose-frame)
                  (windows-transient-window)) :transient nil)
      ("ti" "↕" (lambda ()
                  (interactive)
                  (flip-frame)
                  (windows-transient-window)) :transient nil)
      ("to" "⟷" (lambda ()
                  (interactive)
                  (flop-frame)
                  (windows-transient-window)) :transient nil)
      ("tc" "⟳" (lambda ()
                  (interactive)
                  (rotate-frame-clockwise)
                  (windows-transient-window)) :transient nil)
      ("ta" "⟲" (lambda ()
                  (interactive)
                  (rotate-frame-anticlockwise)
                  (windows-transient-window)) :transient nil)]
     ["Exit"
      ("<escape>" "exit menu" (lambda ()
                                (interactive)
                                (transient-quit-one)) :transient nil)
      ("q" "exit menu" (lambda ()
                         (interactive)
                         (transient-quit-one)) :transient nil)]]))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package transpose-frame
  :ensure t
  :after transient)
#+end_src

* Winner

#+begin_src emacs-lisp :tangle yes
(use-package winner
  :ensure nil
  :hook after-init
  :commands (winner-undo winnner-redo)
  :custom
  (winner-boring-buffers '("*Completions*" "*Help*" "*Apropos*"
                           "*Buffer List*" "*info*" "*Compile-Log*")))
#+end_src

* Email

** Introduction

Trying out this Email thing and see how it works out. For now I've copied/modified the config from [[https://github.com/protesilaos/dotfiles/blob/master/emacs/.emacs.d/prot-emacs-modules/prot-emacs-email.el][Prot]], I'll be tweaking it to my own liking if I can get my head around it.

Anyway, the thing with email in Emacs is that it can't really fetch or send mail. Instead, it calls command-line utilities, which need to be configured properly, to do the heavy lifting. Emacs is used for what it does best - editing, searching and managing text.

I use [[https://isync.sourceforge.io/mbsync.html][mbsync]] for fetching mail, [[https://notmuchmail.org/][notmuch]] for indexing and processing it and =smtpmail= for sending it.

My =.mbsyncrc= config file looks like this:

#+begin_src
IMAPAccount kapsi
Host mail.kapsi.fi
User my-username
PassCmd "echo $KAPSI_PASS"
Port 993
TLSType IMAPS

IMAPStore kapsi-remote
Account kapsi

MaildirStore kapsi-local
Path ~/mail/kapsi/
Inbox ~/mail/kapsi/INBOX
SubFolders Verbatim

Channel kapsi
Near :kapsi-local:
Far :kapsi-remote:
Patterns * !Junk
Create Far
Sync All
Expunge None
SyncState ~/mail/imap-transfer
#+end_src

As to the =.authinfo.gpg= that stores the credentials for sending mail, it looks like this (after decryption):

#+begin_src
machine kapsi port 465 login my-username password my-password
#+end_src

To automate fetching and indexing new mail, I've set up a cron job that runs at a five-minute interval:

#+begin_src bash
*/5 * * * * . $HOME/check-mail.sh
#+end_src

Here the =check-mail.sh= script looks like this.

#+begin_src bash
#!/bin/zsh
source $HOME/.zprofile
/opt/homebrew/bin/mbsync -a && /opt/homebrew/bin/notmuch new
#+end_src

The idea with the setup is to get the secrets exported into shell variables in =.zprofile= in use for the cron job.

I do not want to setup any notifications for mail.

** Config

#+begin_src emacs-lisp :tangle yes
(use-package notmuch
  :ensure t
  :defer t
  :commands (notmuch notmuch-mua-new-mail))

;;;; General UI
(use-package notmuch
  :defer t
  :config
  (setq notmuch-show-logo nil
        notmuch-column-control 1.0
        notmuch-hello-auto-refresh t
        notmuch-hello-recent-searches-max 20
        notmuch-hello-thousands-separator ""
        notmuch-hello-sections '(notmuch-hello-insert-saved-searches)
        notmuch-show-all-tags-list t))

;;;; Search
(use-package notmuch
  :defer t
  :config
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-search-result-format
        '(("date" . "%12s  ")
          ("count" . "%-7s  ")
          ("authors" . "%-20s  ")
          ("subject" . "%-20s  ")
          ("tags" . "(%s)")))
  (setq notmuch-tree-result-format
        '(("date" . "%12s  ")
          ("authors" . "%-20s  ")
          ((("tree" . "%s")
            ("subject" . "%s"))
           . " %-20s  ")
          ("tags" . "(%s)")))
  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . italic)))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-fcc-dirs "sent +sent +new -unread")
  (setq notmuch-saved-searches
        `((:name "all unread (inbox)"
                 :query "tag:unread and tag:inbox"
                 :sort-order newest-first
                 :key ,(kbd "u"))
          (:name "work"
                 :query "tag:inbox and tag:work"
                 :sort-order newest-first
                 :key ,(kbd "z"))
          (:name "flagged"
                 :query "tag:inbox and tag:flagged"
                 :sort-order newest-first
                 :key ,(kbd "x"))
          (:name "undeleted in inbox"
                 :query "tag:inbox and not tag:deleted"
                 :sort-order newest-first
                 :key ,(kbd "p"))
          (:name "sent"
                 :query "tag:sent and not tag:deleted"
                 :sort-order newest-first
                 :key ,(kbd "ö"))
          (:name "inbox"
                 :query "tag:inbox"
                 :sort-order newest-first
                 :key ,(kbd "i")))))

;;;; Tags
(use-package notmuch
  :defer t
  :config
  (setq notmuch-archive-tags nil
        notmuch-message-replied-tags '("+replied")
        notmuch-message-forwarded-tags '("+forwarded")
        notmuch-show-mark-read-tags '("-unread")
        notmuch-draft-tags '("+draft")
        notmuch-draft-folder "drafts"
        notmuch-draft-save-plaintext 'ask)
  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged)
           (concat tag "🚩")))
        notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag 'notmuch-tag-deleted)
           (concat "👁️‍🗨️" tag))
          (".*" (notmuch-apply-face tag 'notmuch-tag-deleted)
           (concat "🚫" tag)))
        notmuch-tag-added-formats
        '(("del" (notmuch-apply-face tag 'notmuch-tag-added)
           (concat "💥" tag))
          (".*" (notmuch-apply-face tag 'notmuch-tag-added)
           (concat "🏷️" tag)))))

;;;; Email composition
(use-package notmuch
  :defer t
  :config
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil)
  (setq notmuch-address-command 'internal)
  (setq notmuch-address-use-company nil)
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function nil)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\|"
                "pi[èe]ce\s+jointe?\\|"
                "συνημμ[εέ]νο\\|επισυν[αά]πτω\\)\\b"))

  (defun prot-notmuch-message-tab ()
    "Override for `message-tab' to enforce header line check.
More specifically, perform address completion when on a relevant header
line, because `message-tab' sometimes (not sure when/how) fails to do
that and instead tries to complete against dictionary entries."
    (interactive nil message-mode)
    (cond
     ((save-excursion
        (goto-char (line-beginning-position))
        (looking-at notmuch-address-completion-headers-regexp))
      (notmuch-address-expand-name)
      ;; Completion was performed; nothing else to do.
      nil)
     (message-tab-body-function (funcall message-tab-body-function))
     (t (funcall (or (lookup-key text-mode-map "\t")
                     (lookup-key global-map "\t")
                     'indent-relative)))))

  (advice-add #'message-tab :override #'prot-notmuch-message-tab))

;;;; Reading messages
(use-package notmuch
  :defer t
  :config
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-view-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-wrap-lines-length 120)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t))

(defun notmuch-sync-email ()
  "Manually sync new mail from server and refresh database."
  (interactive)
  (async-shell-command "mbsync -a && notmuch new")
  (notmuch-refresh-all-buffers))

;;;; Hooks and key bindings
(use-package notmuch
  :hook
  (notmuch-mua-send . notmuch-mua-attachment-check) ; also see `notmuch-mua-attachment-regexp'
  (notmuch-show . (lambda () (setq-local header-line-format nil)))
  :config
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (remove-hook 'notmuch-search-hook #'notmuch-hl-line-mode) ; Check my `lin' package
  :bind
  ( :map global-map
    ("C-x m" . notmuch-mua-new-mail) ; override `compose-mail'
    :map notmuch-search-mode-map ; I normally don't use the tree view, otherwise check `notmuch-tree-mode-map'
    ("/" . notmuch-search-filter) ; alias for l
    ("r" . notmuch-search-reply-to-thread) ; easier to reply to all by default
    ("R" . notmuch-search-reply-to-thread-sender)
    :map notmuch-show-mode-map
    ("a" . nil) ; the default is too easy to hit accidentally and I do not archive stuff
    ("A" . nil)
    ("r" . notmuch-show-reply) ; easier to reply to all by default
    ("R" . notmuch-show-reply-sender)
    :map notmuch-hello-mode-map
    ("C-<tab>" . nil)
    ("§" . notmuch-sync-email)))

;;; My own tweaks for notmuch (prot-notmuch.el)
(use-package prot-notmuch
  :ensure nil
  :after notmuch
  :bind
  ( :map notmuch-search-mode-map
    ("D" . prot-notmuch-search-delete-thread)
    ("S" . prot-notmuch-search-spam-thread)
    ("g" . prot-notmuch-refresh-buffer)
    :map notmuch-show-mode-map
    ("D" . prot-notmuch-show-delete-message)
    ("S" . prot-notmuch-show-spam-message)
    :map notmuch-show-stash-map
    ("S" . prot-notmuch-stash-sourcehut-link))
  :config
  ;; Those are for the actions that are available after pressing 'k'
  ;; (`notmuch-tag-jump').  For direct actions, refer to the key
  ;; bindings below.
  (setq notmuch-tagging-keys
        `((,(kbd "d") prot-notmuch-mark-delete-tags "💥 Mark for deletion")
          (,(kbd "f") prot-notmuch-mark-flag-tags "🚩 Flag as important")
          (,(kbd "s") prot-notmuch-mark-spam-tags "🔥 Mark as spam")
          (,(kbd "r") ("-unread") "👁️‍🗨️ Mark as read")
          (,(kbd "u") ("+unread") "🗨️ Mark as unread"))))

;;; Glue code for notmuch and org-link (ol-notmuch.el)
(use-package ol-notmuch
  :ensure t
  :after notmuch)

;;;; File with authentication credentials (`auth-source')
(use-package auth-source
  :ensure nil
  :defer t
  :config
  (setq auth-sources '("~/.authinfo.gpg")
        user-full-name "Tuomo Virolainen"
        user-mail-address "tuomo.virolainen@kapsi.fi"))

;;;; Encryption settings (`mm-encode' and `mml-sec')
(use-package mm-encode
  :ensure nil
  :defer t
  :config
  (setq mm-encrypt-option nil ; use 'guided for both if you need more control
        mm-sign-option nil))

(use-package mml-sec
  :ensure nil
  :defer t
  :config
  (setq mml-secure-openpgp-encrypt-to-self t
        mml-secure-openpgp-sign-with-sender t
        mml-secure-smime-encrypt-to-self t
        mml-secure-smime-sign-with-sender t))

;;;; Message composition (`message')

(use-package message
  :ensure nil
  :defer t
  :hook
  (message-setup . message-sort-headers)
  :config
  (setq mail-user-agent 'message-user-agent
        message-mail-user-agent t) ; use `mail-user-agent'
  (setq mail-header-separator "--text follows this line--")
  (setq message-elide-ellipsis "\n> [... %l lines elided]\n")
  (setq compose-mail-user-agent-warnings nil)
  (setq message-citation-line-function #'message-insert-formatted-citation-line)
  (setq message-citation-line-format (concat "> From: %f\n"
                                             "> Date: %a, %e %b %Y %T %z\n"
                                             ">")
        message-ignored-cited-headers "") ; default is "." for all headers
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  ;; (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))
  (setq message-wide-reply-confirm-recipients nil))

;;;; Add attachments from Dired (`gnus-dired' does not require `gnus')
(use-package gnus-dired
  :ensure nil
  :after message
  :hook
  (dired-mode . turn-on-gnus-dired-mode))

;;;; `sendmail' (mail transfer agent)
(use-package smtpmail
  :ensure nil
  :after message
  :config
  (setq send-mail-function #'smtpmail-send-it)
  (setq smtpmail-smtp-server "mail.kapsi.fi")
  (setq smtpmail-smtp-service 587)
  (setq smtpmail-stream-type 'starttls))
        #+end_src

* Helpful

[[https://github.com/Wilfred/helpful][Helpful]] seems to be useful. It provides more information about things than the built-in help system.

#+begin_src emacs-lisp :tangle yes
(use-package helpful
  :ensure t
  :config
  (define-key help-map "f" #'helpful-callable)
  (define-key help-map "k" #'helpful-key)
  (define-key help-map "x" #'helpful-command)
  (define-key help-map "F" #'helpful-function)
  ;; Lookup the current symbol at point. C-c C-d is a common keybinding
  ;; for this in lisp modes.
  (global-set-key (kbd "C-c C-d") #'helpful-at-point))
#+end_src

* Ztree

Ztree is /"A major mode for displaying the directory tree in text mode"/. One thing I sometimes need is =ztree-diff= for generating a diff of two directories.

#+begin_src emacs-lisp :tangle yes
(use-package ztree
  :ensure t)
#+end_src

* Package development helpers

Tools to aid with package development.

** package-lint

#+begin_src emacs-lisp :tangle yes
(use-package package-lint
  :ensure t)
#+end_src

** pkg-lint

#+begin_src emacs-lisp :tangle yes
(use-package pkg-info
  :ensure t)
#+end_src

* Crux

A powerful collection of utility functions.

#+begin_src emacs-lisp :tangle yes
(use-package crux
  :ensure t
  :bind (("C-c b" . crux-cleanup-buffer-or-region)
         ("C-c D" . crux-delete-file-and-buffer)
         ("C-c k" . crux-kill-buffer-truename)))
#+end_src

* Various minor tweaks

** Pull GPG passphrases from environment variables to Emacs registers

Read a GPG passphrase from environment variable to a register for easier access.

#+begin_src emacs-lisp :tangle yes
(when work-laptop-p
  (set-register ?o (getenv (base64-decode-string "VkFSTUFfR1BHX1NZTU1FVFJJQ19QQVNTUEhSQVNF")))
  (set-register ?p (getenv (base64-decode-string "VkFSTUFfR1BHX1NZTU1FVFJJQ19QQVNTUEhSQVNFX1BST0Q="))))
#+end_src

** Jump to scratch buffer

Bind a key combination to take me straight to the scratch buffer.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c Å") '(lambda ()
                                 (interactive)
                                 (switch-to-buffer "*scratch*")))
#+end_src

** Kill buffers at scale

Clean up some buffers. Modified from: https://themagitian.github.io/posts/emacsconfig/.

#+begin_src emacs-lisp :tangle yes
(defun tv/kill-other-buffers ()
  "Keep only the current buffer and scratch buffer, kill all others."
  (interactive)
  (let ((buffers-to-keep (cons (buffer-name)
                               '("*scratch*" "*Minibuf-0*" "*Minibuf-1*" "*Echo Area 0*" "*mood-line*"))))
    (mapc (lambda (buffer)
            (let ((bname (string-trim (buffer-name buffer))))
              (unless (member bname buffers-to-keep)
                (kill-buffer buffer))))
          (buffer-list)))
  (message "Killed other buffers"))

(global-set-key (kbd "C-c å") 'tv/kill-other-buffers)
#+end_src

** Quickly visit and evaluate configuration

Source: https://github.com/daedreth/UncleDavesEmacs.

#+begin_src emacs-lisp :tangle yes
(defun tv/config-visit ()
  "Open the configuration file."
  (interactive)
  (find-file (expand-file-name config-file user-emacs-directory)))

(defun tv/config-reload ()
  "Reload config.org."
  (interactive)
  (org-babel-load-file (expand-file-name config-file user-emacs-directory)))

(global-set-key (kbd "C-c e") 'tv/config-visit)
(global-set-key (kbd "C-c r") 'tv/config-reload)
#+end_src

** Sudo current buffer

From [[https://github.com/abrochard/emacs-config][abrochard]].

#+begin_src emacs-lisp :tangle yes
(defun tv/sudo ()
  "Use TRAMP to `sudo' the current buffer"
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+end_src

** Sort buffer

Sort all lines in a buffer.

#+begin_src emacs-lisp :tangle yes
(defun tv/sort-buffer ()
  "Select the lines in a buffer."
  (interactive)
  (sort-lines nil (point-min) (point-max)))
#+end_src

** Generate scratch buffer

From [[https://github.com/abrochard/emacs-config][abrochard]].

#+begin_src emacs-lisp :tangle yes
(defun tv/generate-scratch-buffer ()
  "Create and switch to a temporary scratch buffer with a random
     name."
  (interactive)
  (switch-to-buffer (make-temp-name "*scratch-")))
#+end_src

** Copy filename and path to clipboard

From [[https://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/][bbatsov]].

#+begin_src emacs-lisp :tangle yes
(defun tv/copy-filename ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      (dired-get-filename)
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

** Base64 wrappers

When doing lots of base64 encoding and decoding, it's more ergonomical to process a word under point with a single command than always define a region first.

#+begin_src emacs-lisp :tangle yes
(defun tv/apply-fn-to-word-under-point (fn)
  (let* ((point-loc (point))
         (bounds (bounds-of-thing-at-point 'symbol))
         (text   (buffer-substring-no-properties (car bounds) (cdr bounds))))
    (when bounds
      (delete-region (car bounds) (cdr bounds))
      (insert (funcall fn text))
      (goto-char point-loc))))

(defun tv/base64-encode-word ()
  "Base64 encode the word under point."
  (interactive)
  (tv/apply-fn-to-word-under-point 'base64-encode-string))

(defun tv/base64-decode-word ()
  "Base64 decode the word under point."
  (interactive)
  (tv/apply-fn-to-word-under-point 'base64-decode-string))

(evil-define-key 'normal 'global (kbd "M-s-e") 'tv/base64-encode-word)
(evil-define-key 'normal 'global (kbd "M-s-d") 'tv/base64-decode-word)
#+end_src

** An inspirational quote

Insert a random 4-line quote from a corpus file on top of the scratch buffer. The corpus on my work laptop is a file containing all the lyrics of Manowar, on the private machine I have the screenplay for The Room.

#+begin_src emacs-lisp :tangle yes
(use-package quotient
  :if (file-directory-p "~/dev/quotient")
  :load-path "~/dev/quotient"
  :custom
  (quotient-corpus "etc/manowar.txt") ;; This needs to be under your Emacs directory.
  (quotient-quote-length 4)
  :hook ((after-init . (lambda ()
                         (setq initial-scratch-message (quotient-generate-quote 'comment)))))
  :bind (("C-c ä" . quotient-set-scratch-message))
  :commands (quotient-set-scratch-message quotient-display-random-quote quotient-generate-quote))
#+end_src

** Open a Jira ticket in the browser

#+begin_src emacs-lisp :tangle yes
(when work-laptop-p

  (defvar visited-jira-issues '())

  (defun tv/jira ()
    (interactive)
    (let* ((ticket-number (if visited-jira-issues
                              (completing-read "Tikettinumero: " visited-jira-issues)
                            (read-string "Tikettinumero: ")))
           (parsed-ticket (if (cl-search "-" ticket-number)
                              ticket-number
                            (concat "UMP-" ticket-number)))
           (url (concat "https://varmajira.eficode.com/browse/" parsed-ticket)))
      (progn
        (push parsed-ticket visited-jira-issues)
        (browse-url url)))))
#+end_src

** Kill processes

From [[https://lmno.lol/alvaro/emacs-quick-kill-process][Xenodium]].

#+begin_src emacs-lisp :tangle yes
(use-package dwim-shell-command
  :ensure t)

(require 'map)
(require 'proced)
(require 'seq)

(defun dwim-shell-commands-kill-process ()
  "Select and kill process."
  (interactive)
  (let* ((pid-width 5)
         (comm-width 25)
         (user-width 10)
         (processes (proced-process-attributes))
         (candidates
          (mapcar (lambda (attributes)
                    (let* ((process (cdr attributes))
                           (pid (format (format "%%%ds" pid-width) (map-elt process 'pid)))
                           (user (format (format "%%-%ds" user-width)
                                         (truncate-string-to-width
                                          (map-elt process 'user) user-width nil nil t)))
                           (comm (format (format "%%-%ds" comm-width)
                                         (truncate-string-to-width
                                          (map-elt process 'comm) comm-width nil nil t)))
                           (args-width (- (window-width) (+ pid-width user-width comm-width 3)))
                           (args (map-elt process 'args)))
                      (cons (if args
                                (format "%s %s %s %s" pid user comm (truncate-string-to-width args args-width nil nil t))
                              (format "%s %s %s" pid user comm))
                            process)))
                  processes))
         (selection (map-elt candidates
                             (completing-read "kill process: "
                                              (seq-sort
                                               (lambda (p1 p2)
                                                 (string-lessp (nth 2 (split-string (string-trim (car p1))))
                                                               (nth 2 (split-string (string-trim (car p2))))))
                                               candidates) nil t)))
         (prompt-title (format "%s %s %s"
                               (map-elt selection 'pid)
                               (map-elt selection 'user)
                               (map-elt selection 'comm))))
    (when (y-or-n-p (format "Kill? %s" prompt-title))
      (dwim-shell-command-on-marked-files
       (format "Kill %s" prompt-title)
       (format "kill -9 %d" (map-elt selection 'pid))
       :utils "kill"
       :error-autofocus t
       :silent-success t))))
#+end_src

** Find and insert all Jira ticket codes at point

Here's a helper function that automates a tiny bit of my workday. During work, I keep my TODOs in an inbox file. All the references to Jira tickets in that file are ones that I've been working on during the day. At the end of the day, I archive the done / killed tasks. By running this function, I can copy all the ticket numbers in the file to the kill ring / clipboard where they can be pasted to our time tracking software. A bit silly, perhaps, but why not?

#+begin_src emacs-lisp :tangle yes
(when work-laptop-p

  (defun tv/kill-ump-numbers ()
    "Find all UMP-XXXXX or MAIJA-XXXXX strings in the buffer and kill them."
    (interactive)
    (let ((matches nil))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "\\(?:UMP\\|MAIJA\\)-[0-9]\\{3,5\\}" nil t)
          (let ((entry (match-string 0)))
            (message entry)
            (unless (member entry matches)
              (push (match-string 0) matches)))))
      (kill-new (mapconcat 'identity (nreverse matches) "\n")))))
#+end_src

** Write mode

Enable nice settings for reading or writing.

#+begin_src emacs-lisp :tangle yes
(define-minor-mode write-mode
  "Enable nice settings for reading or writing."
  :init-value nil
  (if write-mode
      (progn
        (olivetti-mode)
        (variable-pitch-mode)
        (display-line-numbers-mode -1))
    (progn
      (olivetti-mode -1)
      (variable-pitch-mode -1)
      (display-line-numbers-mode))))
#+end_src

** Tetris

No Evil mode when playing Tetris.

#+begin_src emacs-lisp :tangle yes
(use-package tetris
  :hook (tetris-mode . turn-off-evil-mode))
#+end_src

** Multi-occur in this mode

From [[https://www.masteringemacs.org/article/searching-buffers-occur-mode][Mastering Emacs]]. This provides an easy way to grep for a phrase in the open buffers that are in the same mode as the one you're currently in.

#+begin_src emacs-lisp :tangle yes
(defun get-buffers-matching-mode (mode)
  "Returns a list of buffers where their major-mode is equal to MODE"
  (let ((buffer-mode-matches '()))
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (eq mode major-mode)
          (push buf buffer-mode-matches))))
    buffer-mode-matches))

(defun multi-occur-in-this-mode ()
  "Show all lines matching REGEXP in buffers with this major mode."
  (interactive)
  (multi-occur
   (get-buffers-matching-mode major-mode)
   (car (occur-read-primary-args))))
#+end_src
