#+title: Config
#+author: Tuomo Virolainen
#+STARTUP: nofold

* Introduction

This is my personal Emacs configuration. After years of using configurations based on [[https://github.com/bbatsov/prelude][Prelude]], [[https://github.com/purcell/emacs.d][Purcell Emacs]] and [[https://github.com/doomemacs/doomemacs][Doom Emacs]] I decided to wipe the table clean and roll my own. While Doom Emacs is great, I wanted to try something more lightweight and minimalist, and to level-up my Elisp.

The way this works is that upon Emacs startup:
1. The two-liner =init.el= config file is loaded, which in turns calls the =org-babel-load-file= function with this file.
2. The org file is processed and the code blocks are tangled into a =config.el= file.
3. The generated configuration file is then loaded. As the =config.el= file is basically a function of this one, I've omitted it from version control.

* General setup

Add personal details.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Tuomo Virolainen"
      user-mail-address "tuomo.virolainen@siili.com")
#+end_src

Configure path.

#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure t
  :init
  (when (memq window-system '(mac ns x))
    (require 'exec-path-from-shell)
    (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE" "MAVEN_OPTS"))
      (add-to-list 'exec-path-from-shell-variables var))
    (exec-path-from-shell-initialize)))
#+end_src

Configure repos.

#+begin_src emacs-lisp :tangle yes
(setq package-enable-at-startup nil
      package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))
#+end_src

Enable =straight.el=.

#+begin_src emacs-lisp :tangle yes
(defvar bootstrap-version)

(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Configure =use-package=.

#+begin_src emacs-lisp :tangle yes
(setq use-package-always-ensure t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile (require 'use-package))
#+end_src

Disable unnecessary stuff.

#+begin_src emacs-lisp :tangle yes
(setq inhibit-startup-screen t)
(blink-cursor-mode -1)
(setq ring-bell-function 'ignore)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Set 50MB as the limit for garbage collection.

#+begin_src emacs-lisp :tangle yes
(setq gc-cons-threshold 50000000)
#+end_src

Warn when opening files bigger than 100MB.

#+begin_src emacs-lisp :tangle yes
(setq large-file-warning-threshold 100000000)
#+end_src

Prefer latest bytecode.

#+begin_src emacs-lisp :tangle yes
(setq load-prefer-newer t)
#+end_src

Increase kill-ring capacity.

#+begin_src emacs-lisp :tangle yes
(setq kill-ring-max 1000)
#+end_src

Shut Emacs down when I'm asking, even if processes are running.

#+begin_src emacs-lisp :tangle yes
(setq confirm-kill-processes nil)
#+end_src

Revert buffers when the underlying file has changed.

#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode 1)

(setq global-auto-revert-non-file-buffers t)
#+end_src

Mac-specific settings.

#+begin_src emacs-lisp :tangle yes
(setq mac-option-modifier 'nil
      mac-command-modifier 'meta
      mac-function-modifier 'super
      select-enable-clipboard t)
#+end_src

UTF-8 should be preferred everywhere.

#+begin_src emacs-lisp :tangle yes
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

Highlight the current line.

#+begin_src emacs-lisp :tangle yes
(use-package hl-line
  :config
  (global-hl-line-mode +1))
#+end_src

Create a directory for savefiles if it doesn't exist.

#+begin_src emacs-lisp :tangle yes
(defconst tv-savefile-dir (expand-file-name "savefile" user-emacs-directory))

(unless (file-exists-p tv-savefile-dir)
  (make-directory tv-savefile-dir))
#+end_src

Put backup files in system's temp dir.

#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

* Tree-sitter

Tree-sitter is the future of language parsing in Emacs. Tree-sitter-based major modes should generally be preferred.

#+begin_src emacs-lisp :tangle yes
(setq treesit-extra-load-path `(,(concat user-emacs-directory "var/tree-sitter-dist/")
                                ,(concat user-emacs-directory "tree-sitter")))
(use-package tree-sitter
  :hook ((tree-sitter-after-on . tree-sitter-hl-mode)
         (prog-mode . turn-on-tree-sitter-mode))
  :config (require 'tree-sitter-langs)
  ;; This makes every node a link to a section of code
  (setq tree-sitter-debug-jump-buttons t
        ;; and this highlights the entire sub tree in your code
        tree-sitter-debug-highlight-jump-region t))

(use-package tree-sitter-langs
  :ensure t
  :after tree-sitter)
#+end_src

* Appearance

Use =doom-dracula= theme.

#+begin_src emacs-lisp :tangle yes
(use-package doom-themes
  :config
  (load-theme 'doom-dracula t))
#+end_src

Add helpers to switch between themes.

#+begin_src emacs-lisp :tangle yes
(defun disable-all-themes ()
  "Disable all enabled custom themes."
  (mapc #'disable-theme custom-enabled-themes))

(defun load-light-theme ()
  "Load light theme."
  (interactive)
  (disable-all-themes)
  (load-theme 'leuven t))

(defun load-dark-theme ()
  "Load dark theme."
  (interactive)
  (disable-all-themes)
  (load-theme 'doom-dracula t))
#+end_src

Setup font.

#+begin_src emacs-lisp :tangle yes
(set-face-attribute 'default nil
                    :family "SF Mono"
                    :height 140)
#+end_src

Tabs should never ever be used for indentation. If they are, they should look as stupid as they are.

#+begin_src emacs-lisp :tangle yes
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src

Require a newline at the end.

#+begin_src emacs-lisp :tangle yes
(setq require-final-newline t)
#+end_src

Maximize the frame on startup.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

Wrap lines by default. I hate horizontal scrolling.

#+begin_src emacs-lisp :tangle yes
(setq global-visual-line-mode t)
#+end_src

Make the titlebar transparent.

#+begin_src emacs-lisp :tangle yes
(set-frame-parameter nil 'ns-transparent-titlebar t)
#+end_src

Remove the icon from the titlebar.

#+begin_src emacs-lisp :tangle yes
(setq ns-use-proxy-icon nil)
#+end_src

Suppress compilation warnings.

#+begin_src emacs-lisp :tangle yes
(setq native-comp-async-report-warnings-errors nil)
#+end_src

Display current time on modeline.

#+begin_src emacs-lisp :tangle yes
(display-time-mode 1)
#+end_src

Scroll smoothly when using a mouse or trackpad. Which is basically never, but anyway...

#+begin_src emacs-lisp :tangle yes
(pixel-scroll-precision-mode)
#+end_src

Setup =mood-line=. It's more minimalist than =doom-modeline=, which is what I need right now.

#+begin_src emacs-lisp :tangle yes
(use-package mood-line
  ;; Enable mood-line
  :config
  (mood-line-mode)
  ;; Use pretty Fira Code-compatible glyphs
  :custom
  (mood-line-glyph-alist mood-line-glyphs-fira-code))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package hide-mode-line
  :ensure t)
#+end_src

Use =spacious-padding=.

#+begin_src emacs-lisp :tangle yes
(use-package spacious-padding
  :ensure t
  :defer
  :hook (after-init . spacious-padding-mode))
#+end_src

Setup line numbers.

#+begin_src emacs-lisp :tangle yes
(setq display-line-numbers-type 'relative)

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'conf-mode #'display-line-numbers-mode)
#+end_src

We don't want line numbers to be shown in org-mode buffers, apart from this one. Here, also =electric-pair-mode= should be enabled.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'(lambda ()
                             (interactive)
                             (when (cl-search "config.org" (buffer-name))
                               (electric-pair-mode)
                               (display-line-numbers-mode))))
#+end_src

** Presentation-mode

Presentation mode scales font sizes up, which is very useful when showing things in meetings etc.

#+begin_src emacs-lisp :tangle yes
(use-package presentation
  :defer
  :ensure t)
#+end_src

** Rainbow-mode

Rainbow mode shows color codes as well as some other values (like the value `red' in CSS) in color.

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode
  :defer
  :ensure t
  :hook (prog-mode . rainbow-mode))
#+end_src

** Rainbow delimiters-mode

Rainbow-delimiters are useful in lisps.

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t)
#+end_src

** Ef-themes

Use ef-themes. They might be useful some day.

#+begin_src emacs-lisp :tangle yes
(use-package ef-themes
  :ensure t
  :defer)
#+end_src

** Modus-themes

Install modus-themes. They too might be useful some day.

#+begin_src emacs-lisp :tangle yes
(use-package modus-themes
  :ensure t
  :defer)
#+end_src

** Olivetti mode

Olivetti mode squeezes the buffer into a column of limited width. This helps readability.

#+begin_src emacs-lisp :tangle yes
(use-package olivetti
  :defer
  :ensure t
  :custom
  (olivetti-body-width 94))
#+end_src

** Pulse

#+begin_src emacs-lisp :tangle yes
(use-package pulse
  :ensure nil
  :defer
  :init
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (dolist (command '(scroll-up-command
                     scroll-down-command
                     evil-scroll-up
                     evil-scroll-down
                     windmove-left
                     windmove-right
                     windmove-up
                     windmove-down
                     move-to-window-line-top-bottom
                     recenter-top-bottom
                     other-window))
    (advice-add command :after #'pulse-line)))
#+end_src

* Evil mode

Vim keybindings here.

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :demand t
  :bind (("<escape>" . keyboard-escape-quit))
  :init
  ;; allows for using cgn
  ;; (setq evil-search-module 'evil-search)
  (setq evil-want-keybinding nil)
  ;; no vim insert bindings
  :config
  (evil-mode 1)
  (setq evil-split-window-below t
        evil-vsplit-window-right t)
  (setq evil-ex-substitute-global t)
  (setq evil-shift-width 2))

(use-package evil-collection
  :after evil
  :config
  (setq evil-want-integration t)
  (evil-collection-init))

(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode))

(use-package evil-owl
  :config
  (setq evil-owl-max-string-length 500)
  (setq evil-owl-idle-delay 0.5)
  (add-to-list 'display-buffer-alist
               '("*evil-owl*"
                 (display-buffer-in-side-window)
                 (side . bottom)
                 (window-height . 0.3)))
  (evil-owl-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'evil
  (defalias #'forward-evil-word #'forward-evil-symbol)
  ;; make evil-search-word look for symbol rather than word boundaries
  (setq-default evil-symbol-word-search t))
#+end_src

This maybe fixes some indentation issues in org mode.

#+begin_src emacs-lisp :tangle yes
(setq evil-want-c-i-jump nil)
#+end_src

[[https://zck.org/balance-emacs-windows][Balance]] windows automatically.

#+begin_src emacs-lisp :tangle yes
(seq-doseq (fn (list #'split-window #'delete-window))
  (advice-add fn
              :after
              #'(lambda (&rest _args) (balance-windows))))
#+end_src

* Version control

Magit is the definitive Git porcelain.

#+begin_src emacs-lisp :tangle yes
(defun kill-magit-diff-buffer-in-current-repo (&rest _)
  "Delete the magit-diff buffer related to the current repo."
  (let ((magit-diff-buffer-in-current-repo
         (magit-mode-get-buffer 'magit-diff-mode)))
    (kill-buffer magit-diff-buffer-in-current-repo)))

(defun mu-magit-kill-buffers ()
  "Restore window configuration and kill all Magit buffers."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))

(use-package magit
  :defer
  :ensure t
  :config
  (add-hook 'git-commit-setup-hook
            (lambda ()
              (add-hook 'with-editor-post-finish-hook
                        #'kill-magit-diff-buffer-in-current-repo
                        nil t)))
  (evil-define-key 'normal magit-status-mode-map
    "q" #'mu-magit-kill-buffers)
  (add-hook 'magit-post-refresh-hook
            #'git-gutter:update-all-windows))

(use-package git-gutter
  :ensure t
  :defer
  :hook (after-init . global-git-gutter-mode))
#+end_src

* Keybindings

Use =which-key=, in minibuffer.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :hook (after-init . which-key-mode)
  :custom
  (which-key-idle-delay 0.5)
  :config
  (which-key-setup-minibuffer))
#+end_src

Make =ESC= quit wherever possible.

#+begin_src emacs-lisp :tangle yes
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

#+begin_src emacs-lisp :tangle yes
(evil-set-leader 'normal (kbd "SPC"))

(defvar my-leader-map (make-sparse-keymap)
  "Keymap for \"leader key\" shortcuts.")

(define-key evil-normal-state-map (kbd "SPC") my-leader-map)
(define-key my-leader-map "b" 'list-buffers)
(define-key my-leader-map (kbd "RET") 'consult-bookmark)
(define-key my-leader-map "<" 'consult-buffer)
(define-key my-leader-map "z" 'consult-recent-file)
#+end_src

A handful of must-have keybindings for me.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal 'global (kbd "ö") 'save-buffer)
(evil-define-key 'normal 'global (kbd "ä") 'delete-other-windows)
(evil-define-key 'normal 'global (kbd "C-ä") 'split-window-right)
(evil-define-key 'normal 'global (kbd "C-ö") 'split-window-below)
(evil-define-key 'normal 'global (kbd "C-å") 'consult-line)
(evil-define-key 'normal 'global (kbd "Ö") 'xref-find-definitions)
(evil-define-key 'normal 'global (kbd "å") 'yank-from-kill-ring)
(evil-define-key 'normal 'global (kbd "¨") 'evil-ex-search-forward)
(evil-define-key 'normal 'global (kbd "C-j") 'evil-window-next)
(evil-define-key 'normal 'global (kbd "C-k") 'evil-window-prev)
(evil-define-key 'normal 'global (kbd "C-h") 'evil-window-left)
(evil-define-key 'normal 'global (kbd "C-l") 'evil-window-right)
(evil-define-key 'normal 'global (kbd "C-u") 'evil-scroll-up)
(evil-define-key 'normal 'global (kbd "DEL") 'paredit-splice-sexp)
(evil-define-key 'normal 'global (kbd "´") 'kill-buffer)
(evil-define-key 'normal 'global (kbd "C-M--") 'ibuffer)
#+end_src

* Flycheck
#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :ensure
  :defer
  :hook ((python-mode . flycheck-mode))
  :bind (:map flycheck-mode-map
              ("C-c C-n" . flycheck-next-error)
              ("C-c C-p" . flycheck-previous-error)))
#+end_src

* Programming languages

** Clojure

Configure the necessary packages.

#+begin_src emacs-lisp :tangle yes
(use-package paredit
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
  ;; enable in the *scratch* buffer
  (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
  (add-hook 'lisp-mode-hook #'paredit-mode))

(defun initialize-kondo ()
  (dolist (checker '(clj-kondo-clj clj-kondo-cljs clj-kondo-cljc clj-kondo-edn))
    (setq flycheck-checkers (cons checker (delq checker flycheck-checkers)))))

(defun my-clojure-mode-hook ()
  (let ((modes (list #'paredit-mode #'subword-mode #'electric-pairs-mode
                     #'rainbow-delimiters-mode #'flycheck-mode
                     #'subword-mode)))
    (dolist (mode modes)
      (mode 1))))

(use-package clojure-mode
  :ensure t
  :config
  (define-clojure-indent
   (returning 1)
   (testing-dynamic 1)
   (testing-print 1)
   (POST 2)
   (GET 2)
   (PATCH 2)
   (PUT 2)))

(use-package inf-clojure
  :ensure t
  :config
  (add-hook 'inf-clojure-mode-hook #'paredit-mode)
  (add-hook 'inf-clojure-mode-hook #'rainbow-delimiters-mode))

(use-package cider
  :ensure t
  :config
  (setq nrepl-log-messages t)
  (add-hook 'cider-repl-mode-hook #'paredit-mode)
  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))

;; (add-hook 'clojure-mode-hook #'eglot)

(defun my-cider-repl-mode-hook ()
  (paredit-mode 1)
  (evil-local-set-key 'insert (kbd "C-<return>") 'paredit-RET)
  (evil-local-set-key 'insert (kbd "RET") 'cider-repl-closing-return)
  (setq cider-repl-buffer-size-limit 20000))

(setq gc-cons-threshold (* 100 1024 1024)
      read-process-output-max (* 1024 1024)
      cider-font-lock-dynamically nil
      cider-repl-buffer-size-limit 1000
      ;; lsp-lens-enable nil ; Show the "1 references" etc text above definitions.
      ;; lsp-enable-indentation nil ; uncomment to use cider indentation instead of lsp
      ;; lsp-completion-enable nil ; uncomment to use cider completion instead of lsp
      )

(add-hook 'cider-repl-mode-hook #'my-cider-repl-mode-hook)
;; (add-hook 'clojure-ts-mode-hook #'my-clojure-mode-hook)

(add-hook 'clojurescript-mode-hook #'paredit-mode)
(add-hook 'clojurescript-mode-hook #'subword-mode)
(add-hook 'clojurescript-mode-hook #'flycheck-mode)
(add-hook 'clojurescript-mode-hook #'rainbow-delimiters-mode)
(add-hook 'clojurescript-mode-hook #'electric-pair-mode)
(add-hook 'clojure-mode-hook #'eglot-ensure)
(add-hook 'clojurescript-mode-hook #'eglot-ensure)
#+end_src

Configure [[https://github.com/ericdallo/jet.el][jet.el]].

#+begin_src emacs-lisp :tangle yes
(use-package jet
  :ensure t
  :defer)
#+end_src

Set keybindings.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal clojure-mode-map
  "°" #'cider-eval-buffer
  "§" #'cider-eval-defun-at-point
  "Ö" #'cider-find-var
  "q" #'cider-popup-buffer-quit
  "K" #'cider-doc)
#+end_src

** SQL

#+begin_src emacs-lisp :tangle yes
(setq sql-postgres-login-params nil)

(setq lsp-sqls-workspace-config-path nil)

(defun maybe-highlight-ms-sql-kws ()
  "Highlight MS SQL keywords when it's certain that's the dialect we're
working with."
  (when (cl-search "umaija" (buffer-file-name))
    (sql-highlight-ms-keywords)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package sql
  :hook ((sql-mode . sqlint-minor-mode))
  :ensure t
  :defer
  :config
  (maybe-highlight-ms-sql-kws)
  (sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode))
#+end_src

Use [[https://github.com/alex-hhh/emacs-sql-indent][Emacs SQL indent]] minor mode.

#+begin_src emacs-lisp :tangle yes
(use-package sql-indent
  :ensure t
  :defer)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package sqlup-mode
  :ensure t
  :defer)
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun tv/indent-sql-buffer ()
  "Since there's some bug that breaks the indentation (`sqlind-indent-line`
specifically) when running it with `newline-and-indent`, I've resorted
to this hack to run the indentation for the whole buffer."
  (interactive)
  (sqlind-minor-mode)
  (indent-region (point-min) (point-max))
  (setq sqlind-minor-mode nil)
  (progn
    (kill-local-variable 'indent-line-function)
    (kill-local-variable 'align-mode-rules-list)))

(defun tv/format-sql-buffer ()
  (interactive)
  (tv/indent-sql-buffer)
  (sqlup-capitalize-keywords-in-region (point-min) (point-max)))

(evil-define-key 'normal sql-mode-map
  "ö" #'(lambda ()
          (interactive)
          (when (< (buffer-size) 4000)
            (tv/format-sql-buffer))
          (save-buffer)))
#+end_src

** Emacs Lisp

Elisp keybindings.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal emacs-lisp-mode-map
  "°" 'eval-buffer
  "§" 'eval-defun)

(evil-define-key 'normal lisp-interaction-mode-map
  "°" 'eval-buffer
  "§" 'eval-defun)

(use-package ielm
  :config
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode))
#+end_src

** Typescript

#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :ensure t
  :defer
  :custom
  (typescript-indent-level 2))
#+end_src

* Restclient

Restclient is essential.

#+begin_src emacs-lisp :tangle yes
(use-package restclient
  :ensure t
  :defer
  :mode ("\\.http\\'" . restclient-mode)
  :init
  (evil-define-key 'normal restclient-mode-map
    "§" 'restclient-http-send-current)
  ;; https://github.com/doomemacs/doomemacs/issues/6073
  (require 'gnutls))
#+end_src

Make it work with =org-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package ob-restclient)
#+end_src

* Counsel-etags

This makes etags work, i.e. allows us to jump to definitions.

#+begin_src emacs-lisp :tangle yes
(use-package counsel-etags
  :ensure t
  :bind (("C-]" . counsel-etags-find-tag-at-point))
  :init
  (add-hook 'prog-mode-hook
        (lambda ()
          (add-hook 'after-save-hook
            'counsel-etags-virtual-update-tags 'append 'local)))
  :config
  (setq counsel-etags-update-interval 60)
  (push "build" counsel-etags-ignore-directories))
#+end_src

* Projectile

#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :ensure t
  :init
  (projectile-global-mode)
  (setq projectile-enable-caching t)
  (setq projectile-project-search-path '("~/dev"))
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

* Editorconfig

Pick up formatting settings from =.editorconfig= files.

#+begin_src emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+end_src

* Ripgrep

Ripgrep package is needed for =projectile-ripgrep= to be usable.

#+begin_src emacs-lisp :tangle yes
(use-package ripgrep
  :ensure t
  :config
  (evil-define-key 'normal 'global "Ä" 'projectile-ripgrep))
#+end_src

* Completion

** Vertico

#+begin_src emacs-lisp :tangle yes
(use-package vertico
  :ensure t
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :init
  (vertico-mode)
  (setq vertico-cycle t))

(use-package vertico-multiform
  :ensure nil
  :hook (after-init . vertico-multiform-mode))
#+end_src

** Dabbrev

#+begin_src emacs-lisp :tangle yes
(use-package dabbrev
  :custom
  (dabbrev-upcase-means-case-search t)
  (dabbrev-check-all-buffers nil)
  (dabbrev-check-other-buffers t)
  (dabbrev-friend-buffer-function 'dabbrev--same-major-mode-p)
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src

** Corfu

#+begin_src emacs-lisp :tangle yes
(use-package corfu
  :ensure t
  ;; Optional customizations
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-on-exact-match 'insert) ;; Insert when there's only one match
  (corfu-quit-no-match t)        ;; Quit when ther is no match
  :init
  (setq corfu-exclude-modes '(eshell-mode))
  (global-corfu-mode))

(use-package cape
  :ensure t
  :init
  (setq cape-dabbrev-min-length 2)
  (setq cape-dabbrev-check-other-buffers 'some)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)

  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input)
                (eq (current-local-map) read-passwd-map))
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
		  corfu-popupinfo-delay nil)
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
  :bind ("C-c SPC" . cape-dabbrev))

#+end_src

** Orderless

#+begin_src emacs-lisp :tangle yes
(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless basic)
	completion-category-defaults nil
	completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle yes
(use-package consult
  :ensure
  :after projectile
  :bind (("C-s" . consult-line)
	 ("C-c M-x" . consult-mode-command)
	 ("C-x b" . consult-buffer)
	 ("C-x r b" . consult-bookmark)
	 ("M-y" . consult-yank-pop)
	 ;; M-g bindings (goto-map)
	 ("M-g M-g" . consult-goto-line)
	 ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
	 ("M-g m" . consult-mark)
	 ("M-g k" . consult-global-mark)
	 ("C-z" . consult-theme)
	 :map minibuffer-local-map
	 ("M-s" . consult-history)                 ;; orig. next-matching-history-element
	 ("M-r" . consult-history)
	 :map projectile-command-map
	 ("b" . consult-project-buffer)
	 :map prog-mode-map
	 ("M-g o" . consult-imenu))

  :init
  (defun remove-items (x y)
    (setq y (cl-remove-if (lambda (item) (memq item x)) y))
    y)

  ;; Any themes that are incomplete/lacking don't work with centaur tabs/solair mode
  (setq consult-project-function (lambda (_) (projectile-project-root)))
  (setq xref-show-xrefs-function #'consult-xref
	xref-show-definitions-function #'consult-xref)
  (setq consult-narrow-key "<")
  (setq consult-line-start-from-top nil))

(use-package consult-ag
  :ensure
  :defer
  :bind (:map projectile-command-map
	      ("s s" . consult-ag)
	      ("s g" . consult-grep)))
#+end_src

** Marginalia

#+begin_src emacs-lisp :tangle yes
(use-package marginalia
  :ensure
  :init
  (marginalia-mode))
#+end_src

** Yasnippet

Yasnippets are very handy, and Doom Emacs contains a nice bundle of them.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :diminish yas-minor-mode
  :init (yas-global-mode)
  :config
  (push '(yasnippet backquote-change) warning-suppress-types)
  (yas-global-mode)
  (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  (setq yas-key-syntaxes '("w_" "w_." "^ "))
  (setq yas-installed-snippets-dir ".config/emacs/snippets")
  (setq yas-expand-only-for-last-commands nil)
  (yas-global-mode 1)
  (bind-key "\t" 'hippie-expand yas-minor-mode-map))

(use-package doom-snippets
  :after yasnippet
  :straight (doom-snippets :type git :host github :repo "doomemacs/snippets" :files ("*.el" "*")))
#+end_src

* History

** Undo-fu

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :ensure t
  :after evil
  :diminish
  :config
  (evil-set-undo-system 'undo-tree)
  (setq undo-tree-history-directory-alist '(("." . "~/.config/emacs/undo")))
  (global-undo-tree-mode 1))
#+end_src

** Save-place-mode

Remember and restore the last cursor location of opened files.

#+begin_src emacs-lisp :tangle yes
(use-package saveplace
  :config
  (setq save-place-file (expand-file-name "saveplace" tv-savefile-dir))
  ;; activate it for all buffers
  (setq-default save-place t))
#+end_src

** Savehist-mode

Remember where we were in the minibuffer.

#+begin_src emacs-lisp :tangle yes
(use-package savehist
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring kill-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        history-length 25
        savehist-save-minibuffer-history 1
        savehist-file (expand-file-name "savehist" tv-savefile-dir))
  (savehist-mode +1))
#+end_src

** Recentf-mode

Enable =recentf-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :config
  (setq recentf-save-file (expand-file-name "recentf" tv-savefile-dir)
        recentf-max-saved-items 500
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)
  (recentf-mode +1))
#+end_src

* File formats
** Docker

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :ensure t
  :defer)

(use-package docker
  :ensure t
  :defer
  :bind ("C-c d" . docker))
#+end_src

** Markdown

#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t
  :mode ("README\\.md\\'" . gfm-mode)
  :init (setq markdown-command "multimarkdown"))
#+end_src

** YAML

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :defer
  :hook (yaml-mode . display-line-numbers-mode))
#+end_src

* Org-mode

#+begin_src emacs-lisp :tangle yes
(use-package org
  :defer
  :custom
  (fill-column 100)
  (org-pretty-entities t)
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-startup-folded 'nofold)
  (org-todo-keywords
   '((sequence "TODO(t)" "PROJ(p)" "LOOP(r)" "STRT(s)" "WAIT(w)"
               "HOLD(h)" "IDEA(i)" "DOING(g)" "|" "DONE(d)" "KILL(k)")
     (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
     (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))
  (org-done ((t (:foreground "PaleGreen"
                             :strike-through t))))
  (org-tags-column 0)
  (org-todo-keyword-faces
   '(("AREA"         . "DarkOrchid1")
     ("[AREA]"       . "DarkOrchid1")
     ("PROJECT"      . "DarkOrchid1")
     ("[PROJECT]"    . "DarkOrchid1")
     ("INBOX"        . "cyan")
     ("[INBOX]"      . "cyan")
     ("PROPOSAL"     . "orange")
     ("[PROPOSAL]"   . "orange")
     ("DRAFT"        . "yellow3")
     ("[DRAFT]"      . "yellow3")
     ("INPROGRESS"   . "yellow4")
     ("[INPROGRESS]" . "yellow4")
     ("MEETING"      . "purple")
     ("[MEETING]"    . "purple")
     ("CANCELED"     . "blue")
     ("[CANCELED]"   . "blue")))
  :config
  (setq org-directory "~/Dropbox/org/")
  (setq org-default-notes-file (concat org-directory "/inbox.org"))
  (setq org-archive-location "archive/Archive_%s::")
  (setq org-ellipsis " ▾")
  (setq org-src-fontify-natively t)
  (setq org-superstar-headline-bullets-list '("› "))
  (setq org-agenda-start-with-log-mode t)
  (setq org-cycle-emulate-tab nil)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sql . t)
     (sqlite . t)
     (python . t)
     (java . t)
     (C . t)
     (emacs-lisp . t)
     (clojure . t)
     (shell . t)))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        org-indent-mode t)
  (setq org-capture-templates
        '(("f" "Fleeting note" item
           (file+headline org-default-notes-file "Notes")
           "- %?"
           :jump-to-captured t)
          ("t" "New task" entry
           (file+headline org-default-notes-file "Tasks")
           "* TODO %i%?")))
  (global-set-key (kbd "C-c c") 'org-capture)
  ;; https://github.com/zzamboni/dot-emacs/blob/master/init.org
  (let* ((variable-tuple
          (cond ((x-list-fonts   "ETBembo")         '(:font   "ETBembo"))
                ((x-list-fonts   "Source Sans Pro") '(:font   "Source Sans Pro"))
                ((x-list-fonts   "Lucida Grande")   '(:font   "Lucida Grande"))
                ((x-list-fonts   "Verdana")         '(:font   "Verdana"))
                ((x-family-fonts "Sans Serif")      '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font."))))
         (headline `(:inherit default :weight bold)))

    (custom-theme-set-faces
     'user
     `(org-level-8        ((t (,@headline ,@variable-tuple))))
     `(org-level-7        ((t (,@headline ,@variable-tuple))))
     `(org-level-6        ((t (,@headline ,@variable-tuple))))
     `(org-level-5        ((t (,@headline ,@variable-tuple))))
     `(org-level-4        ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3        ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2        ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1        ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-headline-done  ((t (,@headline ,@variable-tuple :strike-through t))))
     `(org-document-title ((t (,@headline ,@variable-tuple
                                          :height 2.0 :underline nil))))))
  
  :hook ((org-mode . visual-line-mode)
         (org-mode . org-modern-mode)
         (org-mode . org-indent-mode)))

;; From elken

(defun org-archive-done-tasks ()
  "Attempt to archive all done tasks in file"
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
   "/DONE" 'file))

(defun org-remove-kill-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-cut-subtree)
     (pop kill-ring)
     (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
   "/KILL" 'file))

(evil-define-key 'normal org-mode-map
  (kbd "C-c DEL a") #'org-archive-done-tasks
  (kbd "C-c DEL k") #'org-remove-kill-tasks)

(use-package hl-todo
  :ensure t
  :defer
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode)))
                    #+end_src

** Evil-org

#+begin_src emacs-lisp :tangle yes
(use-package evil-org
  :ensure t
  :after org
  :hook (org-mode . evil-org-mode)
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)

  (defun tv/org-todo-toggle ()
    (interactive)
    (let ((state (org-get-todo-state)))
      (cond ((string= state "[ ]") (org-todo "[X]"))
             ((string= state "[X]") (org-todo "[ ]"))
             ((string= state "TODO") (org-todo "DOING"))
             ((string= state "DOING") (org-todo "DONE"))
             ((string= state "DONE") (org-todo "TODO"))
             (t (message state))))
      (org-flag-subtree t))

  (evil-define-key 'normal org-mode-map
    (kbd "RET") #'tv/org-todo-toggle))
#+end_src

** Org Roam

#+begin_src emacs-lisp :tangle yes
(use-package org-roam
  :ensure t
  :defer
  :custom
  (org-roam-v2-ack t)
  (org-roam-tag-sources '(prop))
  (org-roam-db-update-method 'immediate)
  :hook (after-init . org-roam-db-autosync-mode)
  :bind (:map global-map
              (("C-c n i" . org-roam-node-insert)
               ("C-c n f" . org-roam-node-find)
               ("C-c n g" . org-roam-graph)
               ("C-c n n" . org-roam-capture)
               ("C-c n d" . org-roam-dailies-capture-today)
               ("C-c n s" . consult-org-roam-search)))
  :config
  (setq org-roam-node-display-template (concat "${title:50} " (propertize "${tags:10}" 'face 'org-tag)))
  (setq org-roam-directory "~/Dropbox/org/roam")
  (setq org-roam-capture-templates
        `(("n" "default note" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+title: ${title}\n#+date: %t\n#+filetags: \n\n ")
           :unnarrowed t)
          ("b" "book" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+author: ${author}\n#+title: ${title}\n#+subtitle: \n#+date: %t\n#+origin: ${origin}\n#+category: \n#+filetags: :kirjat:\n\n")
           :unnarrowed t)
          ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
           :unnarrowed t)
          ("m" "meeting" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+title: %^{title}\n#+present: %^{present} \n#+date: %t\n#+category: \n#+filetags: :työ:\n\n ")
           :unnarrowed t))))
#+end_src

** Org Agenda

#+begin_src emacs-lisp :tangle yes
(use-package org-agenda
  :after org
  :ensure nil
  :bind (("C-c a" . org-agenda))
  ;; :hook (org-agenda-finalize . org-agenda-entry-text-mode)
  :custom
  (org-agenda-current-time-string (if (and (display-graphic-p)
                                           (char-displayable-p ?←)
                                           (char-displayable-p ?─))
                                      "← now"
                                    "now - - - - - - - - - - - - - - - - - - - - - - - - -"))
  (org-agenda-timegrid-use-ampm t)
  (org-agenda-tags-column 0)
  (org-agenda-window-setup 'only-window)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-log-mode-items '(closed clock state))
  (org-agenda-time-grid '((daily today require-timed)
                          (600 800 1000 1200 1400 1600 1800 2000)
                          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  ;; (org-agenda-start-with-log-mode '(closed clock state))
  (org-agenda-files (list org-default-notes-file))
  ;; (org-agenda-todo-ignore-scheduled 'future)
  ;; TODO entries that can't be marked as done b/c of children are shown as dimmed in agenda view
  (org-agenda-dim-blocked-tasks 'invisible)
  ;; Start the week view on whatever day im on
  (org-agenda-start-on-weekday nil)
  ;; How to identify stuck/non-stuck projects
  ;; Projects are identified by the 'project' tag and its always the first level
  ;; Next any of these todo keywords means it's not a stuck project
  ;; 3rd, theres no tags that I use to identify a stuck Project
  ;; Finally, theres no special text that signify a non-stuck project
  (org-stuck-projects
   '("+project+LEVEL=1"
     ("IN-PROGRESS" "WAITING" "DONE" "CANCELED" "DELEGATED")
     nil
     ""))
  (org-agenda-prefix-format
   '((agenda . " %-4e %i %-12:c%?-12t% s ")
     (todo . " %i %-10:c %-5e %(gopar/get-schedule-or-deadline-if-available)")
     (tags . " %i %-12:c")
     (search . " %i %-12:c")))
  ;; Lets define some custom cmds in agenda menu
  (org-agenda-custom-commands
   '(("h" "Agenda and Home tasks"
      ((agenda "" ((org-agenda-span 2)))
       (todo "WAITING|IN-PROGRESS")
       (tags-todo "inbox|break")
       (todo "NEXT"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("w" "Agenda and break|inbox tasks"
      ((agenda "" ((org-agenda-span 1)))
       (tags-todo "inbox|break"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("i" "In-Progress Tasks"
      ((todo "IN-PROGRESS|WAITING")
       (agenda ""))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("g" "Goals: 12 Week Year"
      ((agenda "")
       (todo "IN-PROGRESS|WAITING"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))
       (org-agenda-tag-filter-preset '("+12WY"))
       (org-agenda-start-with-log-mode '(closed clock state))
       (org-agenda-archives-mode t)
       ))

     ("r" "Weekly Review"
      ((agenda "")
       (todo))
      ((org-agenda-sorting-strategy '(time-up habit-up category-up priority-down ))
       (org-agenda-files "~/Dropbox/org/weekly-reivew-agenda-files.org")
       (org-agenda-include-diary nil)))))
  :init
  ;; Originally from here: https://stackoverflow.com/a/59001859/2178312
  (defun gopar/get-schedule-or-deadline-if-available ()
    (let ((scheduled (org-get-scheduled-time (point)))
          (deadline (org-get-deadline-time (point))))
      (if (not (or scheduled deadline))
          (format "🗓️ ")
        ;; (format " ")
        "   "))))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package org-present
  :ensure t
  :defer)
#+end_src

* Elfeed

RSS feeds are a convenient way to consume information on a pull-basis from different sources. I can't be bothered to tweak the stock elfeed experience too much.

#+begin_src emacs-lisp :tangle yes
(use-package elfeed
  :defer
  :ensure t
  :init
  (elfeed-org)
  :config
  (setq elfeed-search-filter "@2-week-ago +unread"
        shr-max-image-proportion 0.6)
  (evil-define-key 'normal elfeed-search-mode-map
    (kbd "M-RET") #'elfeed-search-browse-url
    (kbd "DEL") #'tv/elfeed-mark-read
    (kbd "M-DEL") #'tv/elfeed-mark-all-as-read
    "§" #'elfeed-update))

(use-package elfeed-org
  :defer
  :ensure t
  :config
  (setq rmh-elfeed-org-files (list "~/Dropbox/org/elfeed.org")))

(defun tv/elfeed-mark-all-as-read ()
  "Mark all elfeed items as read."
  (interactive)
  (when (equal 'elfeed-search-mode major-mode)
    (elfeed-untag elfeed-search-entries 'unread)
    (elfeed-search-update :force)))

(defun tv/elfeed-mark-read (entry)
  "Display the currently selected item in a buffer."
  (interactive (list (elfeed-search-selected :ignore-region)))
  (when (elfeed-entry-p entry)
    (elfeed-untag entry 'unread)
    (elfeed-search-update-entry entry)
    (unless elfeed-search-remain-on-entry (forward-line))))

(defun tv/elfeed-kill-buffers ()
  "Kill elfeed buffer and the elfeed.org feed definition buffer."
  (interactive)
  (let ((buffer (get-buffer "elfeed.org")))
    (kill-buffer buffer)
    (elfeed-kill-buffer)))
#+end_src

* Shell stuff

** General

Use ansi-colors in shell.

#+begin_src emacs-lisp :tangle yes
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

** Eshell

#+begin_src emacs-lisp :tangle yes
(use-package eshell
  :hook (eshell-mode . hide-mode-line-mode)
  :init
  (setq eshell-scroll-to-bottom-on-input 'all
        eshell-error-if-no-glob t
        eshell-hist-ignoredups t
        eshell-save-history-on-exit t
        eshell-prefer-lisp-functions nil
        eshell-destroy-buffer-when-process-dies t))
#+end_src

Use syntax highlighting in =eshell=.

#+begin_src emacs-lisp :tangle yes
(use-package eshell-syntax-highlighting
  :ensure t
  :config
  (eshell-syntax-highlighting-global-mode +1)
  :init
  (defface eshell-syntax-highlighting-invalid-face
    '((t :inherit diff-error))
    "Face used for invalid Eshell commands."
    :group 'eshell-syntax-highlighting))
#+end_src

Copied from [[https://github.com/abrochard/emacs-config/blob/master/configuration.org][abrochard]].

#+begin_src emacs-lisp :tangle yes
(defun eshell-here ()
  "Opens up a new shell in the directory associated with the
    current buffer's file. The eshell is renamed to match that
    directory to make multiple eshell windows easier."
  (interactive)
  (let* ((height (/ (window-total-height) 3)))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (insert (concat "ls"))
    (eshell-send-input)))

(bind-key "C-!" 'eshell-here)
#+end_src

** Vterm

#+begin_src emacs-lisp :tangle yes
(use-package vterm
  :ensure t
  :defer
  :custom
  (vterm-max-scrollback 100000)
  :config
  (setq vterm-shell "/bin/zsh")
  (setq vterm-kill-buffer-on-exit t)
  (setq vterm-max-scrollback 100000)
  (setq vterm-keymap-exceptions nil))

(use-package multi-vterm
  :after vterm
  :config (add-hook 'vterm-mode-hook
                    (lambda ()
                      (evil-insert-state))))
#+end_src

* Pass

Use the =pass= package to interact with the similarly named Linux password manager.

#+begin_src emacs-lisp :tangle yes
(use-package pass
  :ensure t
  :defer
  :config
  (setq epg-pinentry-mode 'loopback)
  (require 'auth-source-pass)
  (auth-source-pass-enable))
#+end_src


* File info

Show information about the file under editing.

#+begin_src emacs-lisp :tangle yes
(use-package file-info
  :ensure t
  :bind (("C-c f" . 'file-info-show)))
#+end_src

* EWW

Disable images.

#+begin_src emacs-lisp :tangle yes
(setq shr-inhibit-images t)
#+end_src

* Dired

#+begin_src emacs-lisp :tangle yes
(use-package dired
  :ensure nil
  :defer
  :hook ((dired-mode . dired-hide-details-mode)
         (dired-mode . hl-line-mode))
  :custom
  (dired-kill-when-opening-new-dired-buffer t) ;; Without this, each directory level opens in its own buffer.
  (dired-do-revert-buffer t)
  (dired-auto-revert-buffer t)
  (delete-by-moving-to-trash t)
  (dired-mouse-drag-files t)
  (dired-dwim-target t)
  :config
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
  (setq dired-dwim-target t)
  (evil-define-key 'normal 'global (kbd "C-M-ä") 'dired-jump))

(use-package all-the-icons-dired
  :ensure t
  :defer
  :hook (dired-mode . all-the-icons-dired-mode)
  :custom
  (all-the-icons-dired-monochrome nil))
#+end_src

* Transient

Modified from [[https://github.com/gopar/.emacs.d][Gopar]].

#+begin_src emacs-lisp :tangle yes
(use-package transient
  :ensure t
  :defer
  :bind ("C-M-o" . windows-transient-window)
  :init
  (transient-define-prefix windows-transient-window ()
   "Display a transient buffer showing useful window manipulation bindings."
    [["Resize"
     ("}" "h+" enlarge-window-horizontally :transient t)
     ("{" "h-" shrink-window-horizontally :transient t)
     ("^" "v+" enlarge-window :transient t)
     ("V" "v-" shrink-window :transient t)]
     ["Split"
    ("v" "vertical" (lambda ()
       (interactive)
       (split-window-right)
       (windmove-right)) :transient t)
    ("x" "horizontal" (lambda ()
       (interactive)
       (split-window-below)
       (windmove-down)) :transient t)
    ("wv" "win-vertical" (lambda ()
       (interactive)
       (select-window (split-window-right))
       (windows-transient-window)) :transient nil)
    ("wx" "win-horizontal" (lambda ()
       (interactive)
       (select-window (split-window-below))
       (windows-transient-window)) :transient nil)]
    ["Misc"
     ("B" "switch buffer" (lambda ()
                            (interactive)
                            (consult-buffer)
                            (windows-transient-window)))
     ("z" "undo" (lambda ()
                  (interactive)
                  (winner-undo)
                  (setq this-command 'winner-undo)) :transient t)
    ("Z" "redo" winner-redo :transient t)]]
    [["Move"
    ("h" "←" windmove-left :transient nil)
    ("j" "↓" windmove-down :transient nil)
    ("l" "→" windmove-right :transient nil)
    ("k" "↑" windmove-up :transient nil)]
    ["Swap"
    ("sh" "←" windmove-swap-states-left :transient t)
    ("sj" "↓" windmove-swap-states-down :transient t)
    ("sl" "→" windmove-swap-states-right :transient t)
    ("sk" "↑" windmove-swap-states-up :transient t)]
    ["Delete"
    ("dh" "←" windmove-delete-left :transient t)
    ("dj" "↓" windmove-delete-down :transient t)
    ("dl" "→" windmove-delete-right :transient t)
    ("dk" "↑" windmove-delete-up :transient t)
    ("D" "This" delete-window :transient t)]
    ["Transpose"
    ("tt" "↜" (lambda ()
                (interactive)
                (transpose-frame)
                (windows-transient-window)) :transient nil)
    ("ti" "↕" (lambda ()
                (interactive)
                (flip-frame)
                (windows-transient-window)) :transient nil)
    ("to" "⟷" (lambda ()
                (interactive)
                (flop-frame)
                (windows-transient-window)) :transient nil)
    ("tc" "⟳" (lambda ()
                (interactive)
                (rotate-frame-clockwise)
                (windows-transient-window)) :transient nil)
    ("ta" "⟲" (lambda ()
                (interactive)
                (rotate-frame-anticlockwise)
                (windows-transient-window)) :transient nil)]
    ["Exit"
     ("<escape>" "exit menu" (lambda ()
                               (interactive)
                               (transient-quit-one)) :transient nil)
     ("q" "exit menu" (lambda ()
                        (interactive)
                        (transient-quit-one)) :transient nil)]]))
#+end_src

* Winner

#+begin_src emacs-lisp :tangle yes
(use-package winner
  :ensure nil
  :hook after-init
  :commands (winner-undo winnner-redo)
  :custom
  (winner-boring-buffers '("*Completions*" "*Help*" "*Apropos*"
                           "*Buffer List*" "*info*" "*Compile-Log*")))
#+end_src

* Notmuch

Email in Emacs.

#+begin_src emacs-lisp :tangle yes
(use-package notmuch
  :ensure t)
#+end_src
