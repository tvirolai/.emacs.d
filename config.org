#+title: Config
#+author: Tuomo Virolainen
#+STARTUP: content

* Introduction

This is my personal Emacs configuration. After years of using configurations based on
[[https://github.com/bbatsov/prelude][Prelude]], [[https://github.com/purcell/emacs.d][Purcell Emacs]] and [[https://github.com/doomemacs/doomemacs][Doom Emacs]]
I decided to wipe the table clean and roll my own. While Doom Emacs is great,
I wanted to try something more lightweight and minimalist, and to level-up my Elisp.

The way this works is that upon Emacs startup:
1. The two-liner =init.el= config file is loaded, which in turns calls the =org-babel-load-file= function with this file.
2. The org file is processed and the code blocks are tangled into a =config.el= file.
3. The generated configuration file is then loaded. As the =config.el= file is basically a function of this one, I've omitted it from version control.

* General setup

Add personal details.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Tuomo Virolainen"
      user-mail-address "tuomo.virolainen@siili.com")
#+end_src

#+begin_src emacs-lisp :tangle yes
(setq load-prefer-newer t)
#+end_src

Configure path.

#+begin_src emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure t
  :init
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+end_src

Configure repos.

#+begin_src emacs-lisp :tangle yes
(setq package-enable-at-startup nil
      package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))
#+end_src

Enable =straight.el=.

#+begin_src emacs-lisp :tangle yes
(defvar bootstrap-version)

(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Configure =use-package=.

#+begin_src emacs-lisp :tangle yes
(setq use-package-always-ensure t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile (require 'use-package))
#+end_src

Disable unnecessary stuff.

#+begin_src emacs-lisp :tangle yes
(setq inhibit-startup-screen t)
(blink-cursor-mode -1)
(setq ring-bell-function 'ignore)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Set 50MB as the limit for garbage collection.

#+begin_src emacs-lisp :tangle yes
(setq gc-cons-threshold 50000000)
#+end_src

Warn when opening files bigger than 100MB.

#+begin_src emacs-lisp :tangle yes
(setq large-file-warning-threshold 100000000)
#+end_src

Increase kill-ring capacity.

#+begin_src emacs-lisp :tangle yes
(setq kill-ring-max 1000)
#+end_src

Shut Emacs down when I'm asking, even if processes are running.

#+begin_src emacs-lisp :tangle yes
(setq confirm-kill-processes nil)
#+end_src

Revert buffers when the underlying file has changed.

#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode 1)

(setq global-auto-revert-non-file-buffers t)
#+end_src

Mac-specific settings.

#+begin_src emacs-lisp :tangle yes
(setq mac-option-modifier 'nil
      mac-command-modifier 'meta
      mac-function-modifier 'super
      select-enable-clipboard t)
#+end_src

UTF-8 should be preferred everywhere.

#+begin_src emacs-lisp :tangle yes
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
#+end_src

Highlight the current line.

#+begin_src emacs-lisp :tangle yes
(use-package hl-line
  :config
  (global-hl-line-mode +1))
#+end_src

Create a directory for savefiles if it doesn't exist.

#+begin_src emacs-lisp :tangle yes
(defconst tv-savefile-dir (expand-file-name "savefile" user-emacs-directory))

(unless (file-exists-p tv-savefile-dir)
  (make-directory tv-savefile-dir))
#+end_src

Configure handling of temp files. Source: [[http://xahlee.info/emacs/emacs/emacs_auto-save_backup.html][Xah Lee]].

#+begin_src emacs-lisp :tangle yes
(defconst tv-savefile-dir (expand-file-name "backup" user-emacs-directory))

(unless (file-exists-p tv-savefile-dir)
  (make-directory tv-savefile-dir))

(setq make-backup-files t)
(setq version-control nil)
(setq backup-by-copying t)
(setq delete-old-versions t)
#+end_src

* Tree-sitter

#+begin_src emacs-lisp :tangle yes
(setq treesit-extra-load-path `(,(concat user-emacs-directory "var/tree-sitter-dist/")
                                ,(concat user-emacs-directory "tree-sitter")))
(use-package tree-sitter
  :hook ((tree-sitter-after-on . tree-sitter-hl-mode)
         (prog-mode . turn-on-tree-sitter-mode))
  :config (require 'tree-sitter-langs)
  ;; This makes every node a link to a section of code
  (setq tree-sitter-debug-jump-buttons t
        ;; and this highlights the entire sub tree in your code
        tree-sitter-debug-highlight-jump-region t))

(use-package tree-sitter-langs
  :ensure t
  :after tree-sitter)
#+end_src

* Appearance

Use =doom-dracula= theme.

#+begin_src emacs-lisp :tangle yes
(use-package doom-themes
  :config
  (load-theme 'doom-dracula t))
#+end_src

Setup font.

#+begin_src emacs-lisp :tangle yes
(cond
 ((find-font (font-spec :name "SF Mono"))
  (set-frame-font "SF Mono-13"))
 ((find-font (font-spec :name "Menlo"))
  (set-frame-font "Menlo-13"))
 ((find-font (font-spec :name "DejaVu Sans Mono"))
  (set-frame-font "DejaVu Sans Mono-13"))
 ((find-font (font-spec :name "Inconsolata"))
  (set-frame-font "Inconsolata-13")))
#+end_src

Configure tab width.

#+begin_src emacs-lisp :tangle yes
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
#+end_src

Maximize the frame on startup.

#+begin_src emacs-lisp :tangle yes
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

Wrap lines by default.

#+begin_src emacs-lisp :tangle yes
(setq global-visual-line-mode t)
#+end_src

Make the titlebar transparent.

#+begin_src emacs-lisp :tangle yes
(set-frame-parameter nil 'ns-transparent-titlebar t)
#+end_src

Suppress compilation warnings.

#+begin_src emacs-lisp :tangle yes
(setq native-comp-async-report-warnings-errors nil)
#+end_src

Display time on modeline.

#+begin_src emacs-lisp :tangle yes
(display-time-mode 1)
#+end_src

Scroll smoothly.

#+begin_src emacs-lisp :tangle yes
(pixel-scroll-precision-mode)
#+end_src

Setup =doom-modeline=.

#+begin_src emacs-lisp :tangle yes
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :config (column-number-mode 1)
  :custom
  (doom-modeline-height 30)
  (doom-modeline-window-width-limit nil)
  (doom-modeline-buffer-file-name-style 'truncate-with-project)
  (doom-modeline-minor-modes nil)
  (doom-modeline-enable-word-count nil)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-buffer-modification-icon t)
  ;; needs display-time-mode to be one
  (doom-modeline-time t)
  (doom-modeline-vcs-max-length 50))
#+end_src

Show the buffer name in orange if the buffer contains unsaved changes.

#+begin_src emacs-lisp :tangle yes
(custom-set-faces
 '(doom-modeline-buffer-modified ((t (:foreground "orange")))))
#+end_src

Use =spacious-padding=.

#+begin_src emacs-lisp :tangle yes
(use-package spacious-padding
  :ensure t
  :defer
  :hook (after-init . spacious-padding-mode))
#+end_src

Setup line numbers.

#+begin_src emacs-lisp :tangle yes
(setq display-line-numbers-type 'relative)

(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

We don't want line numbers to be shown in org-mode buffers, apart from this one.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'(lambda ()
                             (interactive)
                             (when (cl-search "config.org" (buffer-name))
                               (display-line-numbers-mode))))
#+end_src

** Presentation-mode

#+begin_src emacs-lisp :tangle yes
(use-package presentation
  :defer
  :ensure t)
#+end_src

** Rainbow-mode

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-mode
  :defer
  :ensure t
  :hook (prog-mode . rainbow-mode))
#+end_src

** Rainbow delimiters-mode

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t)
#+end_src

* Evil mode

#+begin_src emacs-lisp :tangle yes
(use-package evil
  :demand t
  :bind (("<escape>" . keyboard-escape-quit))
  :init
  ;; allows for using cgn
  ;; (setq evil-search-module 'evil-search)
  (setq evil-want-keybinding nil)
  ;; no vim insert bindings
  :config
  (evil-mode 1)
  (setq evil-undo-system 'undo-redo)
  (setq evil-split-window-below t
        evil-vsplit-window-right t)
  (setq evil-ex-substitute-global t)
  (setq evil-shift-width 2))

(use-package evil-collection
  :after evil
  :config
  (setq evil-want-integration t)
  (evil-collection-init))

(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode))

(use-package evil-owl
  :config
  (setq evil-owl-max-string-length 500)
  (setq evil-owl-idle-delay 0.5)
  (add-to-list 'display-buffer-alist
               '("*evil-owl*"
                 (display-buffer-in-side-window)
                 (side . bottom)
                 (window-height . 0.3)))
  (evil-owl-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'evil
  (defalias #'forward-evil-word #'forward-evil-symbol)
  ;; make evil-search-word look for symbol rather than word boundaries
  (setq-default evil-symbol-word-search t))
#+end_src

This maybe fixes some indentation issues in org mode.

#+begin_src emacs-lisp :tangle yes
(setq evil-want-c-i-jump nil)
#+end_src

[[https://zck.org/balance-emacs-windows][Balance]] windows automatically.

#+begin_src emacs-lisp :tangle yes
(seq-doseq (fn (list #'split-window #'delete-window))
  (advice-add fn
              :after
              #'(lambda (&rest _args) (balance-windows))))
#+end_src

* Version control

#+begin_src emacs-lisp :tangle yes
(defun kill-magit-diff-buffer-in-current-repo (&rest _)
  "Delete the magit-diff buffer related to the current repo."
  (let ((magit-diff-buffer-in-current-repo
         (magit-mode-get-buffer 'magit-diff-mode)))
    (kill-buffer magit-diff-buffer-in-current-repo)))

(defun mu-magit-kill-buffers ()
  "Restore window configuration and kill all Magit buffers."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))

(use-package magit
  :defer
  :ensure t
  :config
  (add-hook 'git-commit-setup-hook
            (lambda ()
              (add-hook 'with-editor-post-finish-hook
                        #'kill-magit-diff-buffer-in-current-repo
                        nil t)))
  (evil-define-key 'normal magit-status-mode-map
    "q" #'mu-magit-kill-buffers))

(use-package git-gutter
  :ensure t
  :defer
  :hook (after-init . global-git-gutter-mode))
#+end_src

* Keybindings

Use =which-key=.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :hook (after-init . which-key-mode)
  :custom
  (which-key-idle-delay 0.5))
#+end_src

Make =ESC= quit wherever possible.

#+begin_src emacs-lisp :tangle yes
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))

(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+end_src

#+begin_src emacs-lisp :tangle yes
(evil-set-leader 'normal (kbd "SPC"))

(defvar my-leader-map (make-sparse-keymap)
  "Keymap for \"leader key\" shortcuts.")

(defvar my-magit-map (make-sparse-keymap)
  "Keymap for \"leader key\" shortcuts.")

(define-key evil-normal-state-map (kbd "SPC") my-leader-map)
(define-key my-leader-map "b" 'list-buffers)
(define-key my-leader-map (kbd "RET") 'consult-bookmark)
(define-key my-leader-map "<" 'consult-buffer)
(define-key my-leader-map "z" 'consult-recent-file)

(define-key evil-normal-state-map (kbd "SPC g") my-magit-map)
(define-key my-magit-map "g" 'magit-status)
#+end_src

A handful of must-have keybindings for me.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal 'global (kbd "ö") 'save-buffer)
(evil-define-key 'normal 'global (kbd "ä") 'delete-other-windows)
(evil-define-key 'normal 'global (kbd "C-ä") 'split-window-right)
(evil-define-key 'normal 'global (kbd "C-ö") 'split-window-below)
(evil-define-key 'normal 'global (kbd "C-å") 'consult-line)
(evil-define-key 'normal 'global (kbd "Ö") 'xref-find-definitions)
(evil-define-key 'normal 'global (kbd "å") 'yank-from-kill-ring)
(evil-define-key 'normal 'global (kbd "¨") 'evil-ex-search-forward)
(evil-define-key 'normal 'global (kbd "C-j") 'evil-window-next)
(evil-define-key 'normal 'global (kbd "C-k") 'evil-window-prev)
(evil-define-key 'normal 'global (kbd "C-h") 'evil-window-left)
(evil-define-key 'normal 'global (kbd "C-l") 'evil-window-right)
(evil-define-key 'normal 'global (kbd "C-u") 'evil-scroll-up)
(evil-define-key 'normal 'global (kbd "DEL") 'paredit-splice-sexp)
(evil-define-key 'normal 'global (kbd "´") 'kill-buffer)
(evil-define-key 'normal 'global (kbd "C-M--") 'ibuffer)
#+end_src


* Flycheck
#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :ensure
  :defer
  :hook ((python-mode . flycheck-mode))
  :bind (:map flycheck-mode-map
              ("C-c C-n" . flycheck-next-error)
              ("C-c C-p" . flycheck-previous-error)))
#+end_src

* Programming languages

** Clojure

Configure the necessary packages.

#+begin_src emacs-lisp :tangle yes
(use-package paredit
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
  ;; enable in the *scratch* buffer
  (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
  (add-hook 'lisp-mode-hook #'paredit-mode))

(defun initialize-kondo ()
  (dolist (checker '(clj-kondo-clj clj-kondo-cljs clj-kondo-cljc clj-kondo-edn))
    (setq flycheck-checkers (cons checker (delq checker flycheck-checkers)))))

(defun my-clojure-mode-hook ()
  (message "clojure mode hook runs")
  (let ((modes (list #'paredit-mode #'subword-mode #'electric-pairs-mode
                     #'rainbow-delimiters-mode #'flycheck-mode
                     #'subword-mode)))
    (dolist (mode modes)
      (mode 1))))

(use-package clojure-mode
  :ensure t
  :config
  (define-clojure-indent
   (returning 1)
   (testing-dynamic 1)
   (testing-print 1)
   (POST 2)
   (GET 2)
   (PATCH 2)
   (PUT 2)))

(use-package inf-clojure
  :ensure t
  :config
  (add-hook 'inf-clojure-mode-hook #'paredit-mode)
  (add-hook 'inf-clojure-mode-hook #'rainbow-delimiters-mode))

(use-package cider
  :ensure t
  :config
  (setq nrepl-log-messages t)
  (add-hook 'cider-repl-mode-hook #'paredit-mode)
  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))

;; (add-hook 'clojure-mode-hook #'eglot)

(defun my-cider-repl-mode-hook ()
  (paredit-mode 1)
  (evil-local-set-key 'insert (kbd "C-<return>") 'paredit-RET)
  (evil-local-set-key 'insert (kbd "RET") 'cider-repl-closing-return)
  (setq cider-repl-buffer-size-limit 20000))

(setq gc-cons-threshold (* 100 1024 1024)
      read-process-output-max (* 1024 1024)
      cider-font-lock-dynamically nil
      cider-repl-buffer-size-limit 1000
      ;; lsp-lens-enable nil ; Show the "1 references" etc text above definitions.
      ;; lsp-enable-indentation nil ; uncomment to use cider indentation instead of lsp
      ;; lsp-completion-enable nil ; uncomment to use cider completion instead of lsp
      )

(add-hook 'cider-repl-mode-hook #'my-cider-repl-mode-hook)
;; (add-hook 'clojure-ts-mode-hook #'my-clojure-mode-hook)

(add-hook 'clojurescript-mode-hook #'paredit-mode)
(add-hook 'clojurescript-mode-hook #'subword-mode)
(add-hook 'clojurescript-mode-hook #'flycheck-mode)
(add-hook 'clojurescript-mode-hook #'rainbow-delimiters-mode)
(add-hook 'clojurescript-mode-hook #'electric-pair-mode)
(add-hook 'clojure-mode-hook #'eglot-ensure)
(add-hook 'clojurescript-mode-hook #'eglot-ensure)
#+end_src

Configure [[https://github.com/ericdallo/jet.el][jet.el]].

#+begin_src emacs-lisp :tangle yes
(use-package jet
  :ensure t
  :defer)
#+end_src

Set keybindings.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal clojure-mode-map
  "°" #'cider-eval-buffer
  "§" #'cider-eval-defun-at-point
  "Ö" #'cider-find-var
  "q" #'cider-popup-buffer-quit
  "K" #'cider-doc)
#+end_src

** SQL

#+begin_src emacs-lisp :tangle yes
(setq sql-postgres-login-params nil)

(setq lsp-sqls-workspace-config-path nil)

(defun maybe-highlight-ms-sql-kws ()
  "Highlight MS SQL keywords when it's certain that's the dialect we're
working with."
  (when (cl-search "umaija" (buffer-file-name))
    (sql-highlight-ms-keywords)))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package sql
  :hook ((sql-mode . sqlint-minor-mode))
  :ensure t
  :defer
  :config
  (maybe-highlight-ms-sql-kws)
  (sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode))
#+end_src

Use [[https://github.com/alex-hhh/emacs-sql-indent][Emacs SQL indent]] minor mode.

#+begin_src emacs-lisp :tangle yes
(use-package sql-indent
  :ensure t
  :defer)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package sqlup-mode
  :ensure t
  :defer)
#+end_src

#+begin_src emacs-lisp :tangle yes
(defun tv/indent-sql-buffer ()
  "Since there's some bug that breaks the indentation (`sqlind-indent-line`
specifically) when running it with `newline-and-indent`, I've resorted
to this hack to run the indentation for the whole buffer."
  (interactive)
  (sqlind-minor-mode)
  (indent-region (point-min) (point-max))
  (setq sqlind-minor-mode nil)
  (progn
    (kill-local-variable 'indent-line-function)
    (kill-local-variable 'align-mode-rules-list)))

(defun tv/format-sql-buffer ()
  (interactive)
  (tv/indent-sql-buffer)
  (sqlup-capitalize-keywords-in-region (point-min) (point-max)))

(evil-define-key 'normal sql-mode-map
  "ö" #'(lambda ()
          (interactive)
          (when (< (buffer-size) 4000)
            (format-sql-buffer))
          (save-buffer)))
#+end_src

** Emacs Lisp

Elisp keybindings.

#+begin_src emacs-lisp :tangle yes
(evil-define-key 'normal emacs-lisp-mode-map
  "°" 'eval-buffer
  "§" 'eval-defun)

(evil-define-key 'normal lisp-interaction-mode-map
  "°" 'eval-buffer
  "§" 'eval-defun)

(use-package ielm
  :config
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode))
#+end_src

** Typescript

#+begin_src emacs-lisp :tangle yes
(use-package typescript-mode
  :ensure t
  :defer
  :custom
  (typescript-indent-level 2))
#+end_src

* Restclient

Restclient is essential.

#+begin_src emacs-lisp :tangle yes
(use-package restclient
  :ensure t
  :defer
  :mode ("\\.http\\'" . restclient-mode)
  :init
  (evil-define-key 'normal restclient-mode-map
    "§" 'restclient-http-send-current)
  ;; https://github.com/doomemacs/doomemacs/issues/6073
  (require 'gnutls))
#+end_src

* Projectile

#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :ensure t
  :init
  (projectile-global-mode)
  (setq projectile-enable-caching t)
  (setq projectile-project-search-path '("~/dev"))
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+end_src

* Ripgrep

Ripgrep package is needed for =projectile-ripgrep= to be usable.

#+begin_src emacs-lisp :tangle yes
(use-package ripgrep
  :ensure t
  :config
  (evil-define-key 'normal 'global "Ä" 'projectile-ripgrep))
#+end_src

* Completion

** Vertico

#+begin_src emacs-lisp :tangle yes
(use-package vertico
  :ensure t
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :init
  (vertico-mode)
  (setq vertico-cycle t))

(use-package vertico-multiform
  :ensure nil
  :hook (after-init . vertico-multiform-mode))
#+end_src

** Dabbrev

#+begin_src emacs-lisp :tangle yes
(use-package dabbrev
  :custom
  (dabbrev-upcase-means-case-search t)
  (dabbrev-check-all-buffers nil)
  (dabbrev-check-other-buffers t)
  (dabbrev-friend-buffer-function 'dabbrev--same-major-mode-p)
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src

** Corfu

#+begin_src emacs-lisp :tangle yes
(use-package corfu
  :ensure t
  ;; Optional customizations
  :custom
  (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                 ;; Enable auto completion
  (corfu-on-exact-match 'insert) ;; Insert when there's only one match
  (corfu-quit-no-match t)        ;; Quit when ther is no match
  :init
  (setq corfu-exclude-modes '(eshell-mode))
  (global-corfu-mode))

(use-package cape
  :ensure t
  :init
  (setq cape-dabbrev-min-length 2)
  (setq cape-dabbrev-check-other-buffers 'some)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)

  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input)
                (eq (current-local-map) read-passwd-map))
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
		  corfu-popupinfo-delay nil)
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
  :bind ("C-c SPC" . cape-dabbrev))

#+end_src

** Orderless

#+begin_src emacs-lisp :tangle yes
(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless basic)
	completion-category-defaults nil
	completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Consult

#+begin_src emacs-lisp :tangle yes
(use-package consult
  :ensure
  :after projectile
  :bind (("C-s" . consult-line)
	 ("C-c M-x" . consult-mode-command)
	 ("C-x b" . consult-buffer)
	 ("C-x r b" . consult-bookmark)
	 ("M-y" . consult-yank-pop)
	 ;; M-g bindings (goto-map)
	 ("M-g M-g" . consult-goto-line)
	 ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
	 ("M-g m" . consult-mark)
	 ("M-g k" . consult-global-mark)
	 ("C-z" . consult-theme)
	 :map minibuffer-local-map
	 ("M-s" . consult-history)                 ;; orig. next-matching-history-element
	 ("M-r" . consult-history)
	 :map projectile-command-map
	 ("b" . consult-project-buffer)
	 :map prog-mode-map
	 ("M-g o" . consult-imenu))

  :init
  (defun remove-items (x y)
    (setq y (cl-remove-if (lambda (item) (memq item x)) y))
    y)

  ;; Any themes that are incomplete/lacking don't work with centaur tabs/solair mode
  (setq consult-project-function (lambda (_) (projectile-project-root)))
  (setq xref-show-xrefs-function #'consult-xref
	xref-show-definitions-function #'consult-xref)
  (setq consult-narrow-key "<")
  (setq consult-line-start-from-top nil))

(use-package consult-ag
  :ensure
  :defer
  :bind (:map projectile-command-map
	      ("s s" . consult-ag)
	      ("s g" . consult-grep)))
#+end_src

** Marginalia

#+begin_src emacs-lisp :tangle yes
(use-package marginalia
  :ensure
  :init
  (marginalia-mode))
#+end_src

** Yasnippet

Yasnippets are very handy, and Doom Emacs contains a nice bundle of them.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :diminish yas-minor-mode
  :init (yas-global-mode)
  :config
  (push '(yasnippet backquote-change) warning-suppress-types)
  (yas-global-mode)
  (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
  (setq yas-key-syntaxes '("w_" "w_." "^ "))
  (setq yas-installed-snippets-dir ".config/emacs/snippets")
  (setq yas-expand-only-for-last-commands nil)
  (yas-global-mode 1)
  (bind-key "\t" 'hippie-expand yas-minor-mode-map))

(use-package doom-snippets
  :after yasnippet
  :straight (doom-snippets :type git :host github :repo "doomemacs/snippets" :files ("*.el" "*")))
#+end_src

* History

** Save-place-mode

Remember and restore the last cursor location of opened files.

#+begin_src emacs-lisp :tangle yes
(use-package saveplace
  :config
  (setq save-place-file (expand-file-name "saveplace" tv-savefile-dir))
  ;; activate it for all buffers
  (setq-default save-place t))
#+end_src

** Savehist-mode

#+begin_src emacs-lisp :tangle yes
(use-package savehist
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring kill-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        history-length 25
        savehist-save-minibuffer-history 1
        savehist-file (expand-file-name "savehist" tv-savefile-dir))
  (savehist-mode +1))
#+end_src

** Recentf-mode

Enable =recentf-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :config
  (setq recentf-save-file (expand-file-name "recentf" tv-savefile-dir)
        recentf-max-saved-items 500
        recentf-max-menu-items 15
        ;; disable recentf-cleanup on Emacs start, because it can cause
        ;; problems with remote files
        recentf-auto-cleanup 'never)
  (recentf-mode +1))
#+end_src

* File formats
** Docker

#+begin_src emacs-lisp :tangle yes
(use-package dockerfile-mode
  :ensure t
  :defer)

(use-package docker
  :ensure t
  :defer
  :bind ("C-c d" . docker))
#+end_src

** Markdown

#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t
  :mode ("README\\.md\\'" . gfm-mode)
  :init (setq markdown-command "multimarkdown"))
#+end_src

** YAML

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :defer
  :hook (yaml-mode . display-line-numbers-mode))
#+end_src

* Org-mode

#+begin_src emacs-lisp :tangle yes
(use-package org
  :defer
  :custom
  (fill-column 100)
  (org-pretty-entities t)
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-startup-folded 'nofold)
  (org-todo-keywords
   '((sequence "TODO(t)" "NEXT(n)" "IN-PROGRESS(i!)" "WAITING(w!)" "|" "DONE(d!)" "CANCELED(c!)" "DELEGATED(p!)")))
  :config
  (setq org-directory "~/Dropbox/org/")
  (setq org-default-notes-file (concat org-directory "/inbox.org"))
  (setq org-ellipsis " ▾")
  (setq org-superstar-headline-bullets-list '("› "))
  (setq org-agenda-start-with-log-mode t)
  (setq org-cycle-emulate-tab nil)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sql . t)
     (sqlite . t)
     (python . t)
     (java . t)
     (C . t)
     (emacs-lisp . t)
     (clojure . t)
     (shell . t)))
  (setq org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        doom-modeline-enable-word-count t
        org-indent-mode t)
  (setq org-capture-templates
        '(("f" "Fleeting note" item
           (file+headline org-default-notes-file "Notes")
           "- %?"
           :jump-to-captured t)
          ("t" "New task" entry
           (file+headline org-default-notes-file "Tasks")
           "* TODO %i%?")))
  (global-set-key (kbd "C-c c") 'org-capture)
  :hook ((org-mode . visual-line-mode)
         (org-mode . org-indent-mode)
         (org-mode . org-modern-mode)))

(use-package org-modern
  :defer
  :ensure t
  :after org)

(use-package hl-todo
  :ensure t
  :defer
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode)))
  #+end_src

** Org Roam

#+begin_src emacs-lisp :tangle yes
(use-package org-roam
  :ensure t
  :defer
  :custom
  (org-roam-v2-ack t)
  (org-roam-tag-sources '(prop))
  (org-roam-db-update-method 'immediate)
  :hook (after-init . org-roam-db-autosync-mode)
  :bind (:map global-map
              (("C-c n i" . org-roam-node-insert)
               ("C-c n f" . org-roam-node-find)
               ("C-c n g" . org-roam-graph)
               ("C-c n n" . org-roam-capture)
               ("C-c n d" . org-roam-dailies-capture-today)
               ("C-c n s" . consult-org-roam-search)))
  :config
  (setq org-roam-node-display-template (concat "${title:50} " (propertize "${tags:10}" 'face 'org-tag)))
  (setq org-roam-directory "~/Dropbox/org/roam")
  (setq org-roam-capture-templates
        `(("n" "default note" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+title: ${title}\n#+date: %t\n#+filetags: \n\n ")
           :unnarrowed t)
          ("b" "book" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+author: ${author}\n#+title: ${title}\n#+subtitle: \n#+date: %t\n#+origin: ${origin}\n#+category: \n#+filetags: :kirjat:\n\n")
           :unnarrowed t)
          ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
           :unnarrowed t)
          ("m" "meeting" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                      "#+title: %^{title}\n#+present: %^{present} \n#+date: %t\n#+category: \n#+filetags: :työ:\n\n ")
           :unnarrowed t))))
#+end_src

** Org Agenda

#+begin_src emacs-lisp :tangle yes
(use-package org-agenda
  :after org
  :ensure nil
  :bind (("C-c a" . org-agenda))
  ;; :hook (org-agenda-finalize . org-agenda-entry-text-mode)
  :custom
  (org-agenda-current-time-string (if (and (display-graphic-p)
           (char-displayable-p ?←)
           (char-displayable-p ?─))
      "⬅️ now"
    "now - - - - - - - - - - - - - - - - - - - - - - - - -"))
  (org-agenda-timegrid-use-ampm t)
  (org-agenda-tags-column 0)
  (org-agenda-window-setup 'only-window)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-log-mode-items '(closed clock state))
  (org-agenda-time-grid '((daily today require-timed)
                          (600 800 1000 1200 1400 1600 1800 2000)
                          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  ;; (org-agenda-start-with-log-mode '(closed clock state))
  (org-agenda-files "~/Dropbox/org/agenda-files.org")
  ;; (org-agenda-todo-ignore-scheduled 'future)
  ;; TODO entries that can't be marked as done b/c of children are shown as dimmed in agenda view
  (org-agenda-dim-blocked-tasks 'invisible)
  ;; Start the week view on whatever day im on
  (org-agenda-start-on-weekday nil)
  ;; How to identify stuck/non-stuck projects
  ;; Projects are identified by the 'project' tag and its always the first level
  ;; Next any of these todo keywords means it's not a stuck project
  ;; 3rd, theres no tags that I use to identify a stuck Project
  ;; Finally, theres no special text that signify a non-stuck project
  (org-stuck-projects
   '("+project+LEVEL=1"
     ("IN-PROGRESS" "WAITING" "DONE" "CANCELED" "DELEGATED")
     nil
     ""))
  (org-agenda-prefix-format
   '((agenda . " %-4e %i %-12:c%?-12t% s ")
     (todo . " %i %-10:c %-5e %(gopar/get-schedule-or-deadline-if-available)")
     (tags . " %i %-12:c")
     (search . " %i %-12:c")))
  ;; Lets define some custom cmds in agenda menu
  (org-agenda-custom-commands
   '(("h" "Agenda and Home tasks"
      ((agenda "" ((org-agenda-span 2)))
       (todo "WAITING|IN-PROGRESS")
       (tags-todo "inbox|break")
       (todo "NEXT"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("w" "Agenda and break|inbox tasks"
      ((agenda "" ((org-agenda-span 1)))
       (tags-todo "inbox|break"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("i" "In-Progress Tasks"
      ((todo "IN-PROGRESS|WAITING")
       (agenda ""))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))))

     ("g" "Goals: 12 Week Year"
      ((agenda "")
       (todo "IN-PROGRESS|WAITING"))
      ((org-agenda-sorting-strategy '(time-up habit-up priority-down category-up))
       (org-agenda-tag-filter-preset '("+12WY"))
       (org-agenda-start-with-log-mode '(closed clock state))
       (org-agenda-archives-mode t)
       ))

     ("r" "Weekly Review"
      ((agenda "")
       (todo))
      ((org-agenda-sorting-strategy '(time-up habit-up category-up priority-down ))
       (org-agenda-files "~/Dropbox/org/weekly-reivew-agenda-files.org")
       (org-agenda-include-diary nil)))))
  :init
  ;; Originally from here: https://stackoverflow.com/a/59001859/2178312
  (defun gopar/get-schedule-or-deadline-if-available ()
    (let ((scheduled (org-get-scheduled-time (point)))
          (deadline (org-get-deadline-time (point))))
      (if (not (or scheduled deadline))
          (format "🗓️ ")
          ;; (format " ")
        "   "))))
#+end_src
* Elfeed

RSS feeds are a convenient way to consume information on a pull-basis from different sources. I can't be bothered to tweak the stock elfeed experience too much.

#+begin_src emacs-lisp :tangle yes
(use-package elfeed
  :defer
  :ensure t
  :init
  (elfeed-org)
  (run-at-time 10 (* 60 60) #'(lambda ()
                                (interactive)
                                (message "Updating RSS feeds...")
                                (elfeed-update)))
  :config
  (setq elfeed-search-filter "@2-week-ago +unread"
        shr-max-image-proportion 0.6)
  (evil-define-key 'normal elfeed-search-mode-map
    (kbd "M-RET") #'elfeed-search-browse-url
    "§" #'elfeed-update))

(use-package elfeed-org
  :defer
  :ensure t
  :config
  (setq rmh-elfeed-org-files (list "~/Dropbox/org/elfeed.org")))

(defun elfeed-mark-all-as-read ()
  "Mark all elfeed items as read."
  (interactive)
  (when (equal 'elfeed-search-mode major-mode)
    (elfeed-untag elfeed-search-entries 'unread)
    (elfeed-search-update :force)))

(defun elfeed-kill-buffers ()
  "Kill elfeed buffer and the elfeed.org feed definition buffer."
  (interactive)
  (let ((buffer (get-buffer "elfeed.org")))
    (kill-buffer buffer)
    (elfeed-kill-buffer)))
#+end_src

* Shell stuff

** Eshell

#+begin_src emacs-lisp :tangle yes
(setq eshell-prefer-lisp-functions t)
#+end_src

Use syntax highlighting in =eshell=.

#+begin_src emacs-lisp :tangle yes
(use-package eshell-syntax-highlighting
  :ensure t
  :config
  (eshell-syntax-highlighting-global-mode +1)
  :init
  (defface eshell-syntax-highlighting-invalid-face
    '((t :inherit diff-error))
    "Face used for invalid Eshell commands."
    :group 'eshell-syntax-highlighting))
#+end_src

** Vterm

#+begin_src emacs-lisp :tangle yes
(use-package vterm
  :ensure t
  :defer
  :custom
  (vterm-max-scrollback 100000)
  :config
  (setq vterm-shell "/bin/zsh")
  (setq vterm-kill-buffer-on-exit t)
  (setq vterm-max-scrollback 100000)
  (setq vterm-keymap-exceptions nil))

(use-package multi-vterm
  :after vterm
  :config (add-hook 'vterm-mode-hook
                    (lambda ()
                      (evil-insert-state))))
#+end_src

* Pass

#+begin_src emacs-lisp :tangle yes
(use-package pass
  :ensure t
  :defer
  :config
  (require 'auth-source-pass)
  (auth-source-pass-enable))
#+end_src


* File info

Show information about the file under editing.

#+begin_src emacs-lisp :tangle yes
(use-package file-info
  :ensure t
  :bind (("C-c f" . 'file-info-show)))
#+end_src

* EWW

Disable images.

#+begin_src emacs-lisp :tangle yes
(setq shr-inhibit-images t)
#+end_src

* Dired

#+begin_src emacs-lisp :tangle yes
(use-package dired
  :ensure nil
  :defer
  :hook ((dired-mode . dired-hide-details-mode)
         (dired-mode . hl-line-mode))
  :custom
  (dired-do-revert-buffer t)
  (dired-auto-revert-buffer t)
  (delete-by-moving-to-trash t)
  (dired-mouse-drag-files t)
  (dired-dwim-target t)
  :config
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
  (setq dired-dwim-target t)
  (evil-define-key 'normal 'global (kbd "C-M-ä") 'dired-jump))

(use-package all-the-icons-dired
  :ensure t
  :defer
  :hook (dired-mode . all-the-icons-dired-mode)
  :custom
  (all-the-icons-dired-monochrome nil))
#+end_src

